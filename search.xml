<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[react-router4.0+]]></title>
    <url>%2F2018%2F05%2F02%2Freact-router4-0%2F</url>
    <content type="text"><![CDATA[使用版本12"react-router": "^4.2.0","react-router-dom": "^4.2.2", 国内现在很多的教程都是使用的是老版本的react-router，随着生态圈的壮大，react-router包也越来越大，而客户端浏览器使用的react-router的功能有非常少，所以将react-router中浏览器使用到的react-router-dom从中分离了出来。我们在开发时可以只安装react-router-dom。 安装1npm i react-router react-router-dom --save 创建模块 模块A1234567import React,&#123;Component&#125; from 'react';export default class A extends Component&#123; render()&#123; return(&lt;h1&gt;我是模块A&lt;/h1&gt;); &#125;&#125; 模块B1234567import React,&#123;Component&#125; from 'react';export default class B extends Component&#123; render()&#123; return(&lt;h1&gt;我是模块B&lt;/h1&gt;); &#125;&#125; 模块C1234567import React,&#123;Component&#125; from 'react';export default class C extends Component&#123; render()&#123; return(&lt;h1&gt;我是模块C&lt;/h1&gt;); &#125;&#125; 配置路由Router路由器Router是一个容器（其实质就是一个React组件），真正的路由配置是由Route定义的，定义的Route（一个或多个）都必须由Router包裹。 1234567import React from 'react';import ReactDOM from 'react-dom';import &#123;BrowserRouter as Router,Route&#125; from 'react-router-dom';ReactDOM.render( &lt;Router&gt;&lt;/Router&gt; ,document.getElementById('root')); Basename用于模拟项目根目录 123456789101112&lt;Router basename='/public'&gt; &lt;div&gt; &lt;Nav/&gt; &lt;Switch&gt; &lt;Route exact path='/' component=&#123;A&#125;/&gt; &lt;Route path='/b/:name' component=&#123;B&#125;/&gt; &lt;Route path='/c' component=&#123;C&#125;/&gt; &lt;Redirect from='/b' to='/b' push/&gt; &lt;Route component=&#123;Err&#125;/&gt; &lt;/Switch&gt; &lt;/div&gt;&lt;/Router&gt; froceRefresh当浏览器不支持HTML5的history API时强制刷新页面。 路由器种类：react-router-dom中包含的路由种类有三种： browserRouter HashRouter MemoryRouter Route路由定义了URL与Component之间的关系，Route可以是多个。 12345678&lt;Router&gt; &lt;div&gt; &lt;Nav/&gt; &lt;Route exact path='/' component=&#123;A&#125;/&gt; &lt;Route path='/b' component=&#123;B&#125;/&gt; &lt;Route path='/c' component=&#123;C&#125;/&gt; &lt;/div&gt;&lt;/Router&gt; Path：url地址 Component：url指向到的对应的模块 Exact：严格匹配，一般情况下，路由会匹配所有能够匹配到的路由组件（比如 ’/c’ 与 ’/’ ），exact会让匹配更加严格，如果是匹配 ’/c ’ 就不能匹配上 ’/’ 12345678&lt;Router&gt; &lt;div&gt; &lt;Nav/&gt; &lt;Route path='/' component=&#123;A&#125;/&gt; &lt;Route path='/b' component=&#123;B&#125;/&gt; &lt;Route path='/c' component=&#123;C&#125;/&gt; &lt;/div&gt;&lt;/Router&gt; 当我点击模块B的时候，此时的路由地址是’/b’,由于路由 ’/’ 没有严格模式的限制，’/b’也将’/’匹配到了。 Demo12345678910111213141516171819import React from 'react';import ReactDOM from 'react-dom';import &#123;BrowserRouter as Router,Route&#125; from 'react-router-dom';import './index.css';import A from './component/a';import B from './component/b';import C from './component/c';import Nav from './component/nav';ReactDOM.render( &lt;Router&gt; &lt;div&gt; &lt;Nav/&gt; &lt;Route exact path='/' component=&#123;A&#125;/&gt; &lt;Route path='/b' component=&#123;B&#125;/&gt; &lt;Route path='/c' component=&#123;C&#125;/&gt; &lt;/div&gt; &lt;/Router&gt; ,document.getElementById('root')); Prompt用户在切换路由时，如果要跳出本模块，用于进行一些提示信息。Prompt有两个属性message与when。Message用返回提示信息，when用于关闭和开启提示信息。 1&lt;Prompt when=&#123;true&#125; message="您确定您要离开当前页面吗？"/&gt; 1&lt;Prompt when=&#123;false&#125; message="您确定您要离开当前页面吗？"/&gt; Switch（开关）Route的匹配具有包含性，如下代码：如果现在我们只是需要匹配”/b”,那么Err模块也会被加载到页面当中。 123&lt;Route path='/b' component=&#123;B&#125;/&gt;&lt;Route path='/c' component=&#123;C&#125;/&gt;&lt;Route component=&#123;Err&#125;/&gt; Switch就是一个分组，switch可以定义多个，他专门为包含的route提供一个路线，如果我们现在只是需要匹配”/b”这个模块，那么只要匹配到”/b”（只要是满足匹配条件的都会停止匹配，如果将Err模块放在最开始，当匹配到Err时也会停止匹配）switch就会关闭匹配路线，不再继续向下匹配。 Redirect重定向当我们进入一个不存在的路由地址，又不想给用户展示空的页面。那么就需要跳转到另一个错误处理或者错误提示亦或者比如首页界面了。Redirect就能帮组我们实现这个功能。 1234567&lt;Switch&gt; &lt;Route exact path='/' component=&#123;A&#125;/&gt; &lt;Route path='/b' component=&#123;B&#125;/&gt; &lt;Route path='/c' component=&#123;C&#125;/&gt; &lt;Redirect from='/d' to='/b' push/&gt; &lt;Route component=&#123;Err&#125;/&gt;&lt;/Switch&gt; 现在点击D模块，跳转路由地址“/d”（“/d”未在route中定义），路由重新跳转到了“/b”。 From地址来源：没有在route中定义（一定要是没有在route定义的）的且用户又跳转了的路由地址。 To路由去向：如果跳转了没有定义的路由地址，那么我们需要将这个地址又指向到哪里去。 PushPush是一个布尔值，在rederict组件中添加push属性，我们在跳转到重定向的模块时，浏览器后退按钮无效。 为什么from一定要未定义的路由地址： 如果from是定义好的路由地址，重定向到”/b”之后switch会关闭掉匹配路线，停止向下匹配，也就不会再次进入到Redirect，所以就会导致redirect中的push失效。 NavLinkNavLink是Link的升级版，他就相当于普通HTML中的a标记，用于生成一个链接。点击NavLink，跳转到NavLink上定义的url对应的路由组件上。现在官方为了版本迭代所以还能在react-router-dom中继续使用Link。 1234567891011121314import React,&#123;Component&#125; from 'react';import &#123;NavLink&#125; from 'react-router-dom';export default class Nav extends Component&#123; render()&#123; return( &lt;div&gt; &lt;NavLink exact to='/'&gt;A模块&lt;/NavLink&gt; &lt;NavLink to='/b'&gt;B模块&lt;/NavLink&gt; &lt;NavLink to='/c'&gt;C模块&lt;/NavLink&gt; &lt;/div&gt; ); &#125;&#125; activeClassName（activeStyle）12345678render()&#123; return( &lt;div&gt; &lt;NavLink exact to='/' activeClassName='active'&gt;A模块&lt;/NavLink&gt; &lt;NavLink to='/b' activeStyle=&#123;&#123;color:'pink',border:'1px solid red'&#125;&#125;&gt;B模块&lt;/NavLink&gt; &lt;NavLink to='/c' activeClassName='active'&gt;C模块&lt;/NavLink&gt; &lt;/div&gt; ); 1234.active&#123; color:pink; border:1px solid red;&#125; activeClassName（activeStyle）与className相同，实质上activeClassName就是className的升级版。activeClassName会使用当前NavLink配置的地址（to）自动与浏览器URL进行匹配，如果URL对应成功，activeClassName这个calss就是生效。 路由传值isActiveisActive属性判断是否激活当前路由，他的值是一个函数，函数默认接收两个参数match和localtion。 12345678910111213141516export default class Nav extends Component&#123; HandlerClick(match,location)&#123; console.log(match); console.log(location); &#125; render()&#123; return( &lt;div&gt; &lt;NavLink exact to='/' activeClassName='active'&gt;A模块&lt;/NavLink&gt; &lt;NavLink isActive=&#123;this.HandlerClick&#125; to='/b' activeClassName='active'&gt;B模块&lt;/NavLink&gt; &lt;NavLink to='/c' activeClassName='active'&gt;C模块&lt;/NavLink&gt; &lt;NavLink to='/d' activeClassName='active'&gt;D模块&lt;/NavLink&gt; &lt;/div&gt; ); &#125;&#125; Get传值1&lt;NavLink isActive=&#123;this.HandlerClick&#125; to='/b?name=tom' activeClassName='active'&gt;B模块&lt;/NavLink&gt; Hash传值1&lt;NavLink isActive=&#123;this.HandlerClick&#125; to='/b#tom' activeClassName='active'&gt;B模块&lt;/NavLink&gt; 这样的获取到的参数如果是需要传递到子模块内部，就需要通过porps层层传递到模块内，这样非常麻烦。 Prop传值1&lt;NavLink isActive=&#123;this.HandlerClick&#125; to='/b/tom' activeClassName='active'&gt;B模块&lt;/NavLink&gt; 123&lt;Switch&gt; &lt;Route path='/b/:name' component=&#123;B&#125;/&gt;&lt;/Switch&gt; 123456componentWillMount()&#123; console.log(this.props)&#125;render()&#123; return(&lt;h1&gt;我是模块&lt;/h1&gt;);&#125; 这样就能在子模块内部非常容易的获取到传递的值 12345678export default class B extends Component&#123; componentWillMount()&#123; console.log(this.props) &#125; render()&#123; return(&lt;h1&gt;我是模块 &#123;this.props.match.params.name&#125;&lt;/h1&gt;); &#125;&#125;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux]]></title>
    <url>%2F2018%2F05%2F02%2Fredux%2F</url>
    <content type="text"><![CDATA[什么是reduxRedux 是 JavaScript 状态容器，提供可预测化的状态管理。Redux是基于Flux的思想，但又避免它的复杂性。 无论您是否使用过它，Redux只需几分钟即可开始使用。如果你的项目没有复杂的交互和数据，就不需要使用redux，只有遇到 React 实在解决不了的问题，你才需要 Redux 。 何时使用redux 多个组件间共享状态 一个组件的状态需要被别的组件使用 设计思想 用户打开视图（view），用户的操作会触发页面中的事件（action） Reducer是一个纯函数，他会接收当前的state和action，reducer会根据传入的action返回新的state Store是作为state的一个集合，包含所有数据，reducer返回新的state的时store也会改变。 Store的更新会同步到页面视图（view）当中 创建Reducer纯函数Reducer是一个纯函数，他会接受两个参数当前state，action，并返回一个新的state。 12345678910export default (state=0,action)=&gt;&#123; switch (action.type)&#123; case 'ADD': return state+1 case 'reduce': return state-1; default: return state; &#125;&#125; 在es6语法当中我们可以直接给state赋一个初始值（state=0），不同的返回值都是更具action的不同。 生成Store通过调用createStore方法生成store，createStore接收reducer纯函数作为参数。 123import &#123;createStore&#125; from 'redux';const store=createStore(reducer); 传递Action123&#123; type:'ADD'&#125; Action中type属性是必须的，其他属性可以自由设置，reducer就是根据action的type返回的新state。 将action传递给reducer在创建好action后，store有一个dispatch（调度中心）方法将action作为参数传递给reducer。 1store.dispatch(&#123;type:'ADD'&#125; 传参数给reducer1store.dispatch(&#123;type:'ADD',count:2&#125;) 获取新State1store.getState() 更新View将ReactDOM.render封装成一个render方法。 123456789101112131415const render=()=&gt;&#123; ReactDOM.render( &lt;div&gt; &lt;Content state=&#123;store.getState()&#125;/&gt; &lt;Btn ADDClick=&#123;()=&gt;store.dispatch(&#123;type:'ADD'&#125;)&#125; ReduceClick=&#123;()=&gt;&#123;store.dispatch(&#123;type:'Reduce'&#125;)&#125;&#125; /&gt; &lt;/div&gt; ,document.getElementById('root') );&#125;;render();//首次渲染store.subscribe(render);//监听state改变，进行更新 store.subscribe（）可以监听store的改变，当store改变时，store.Subscribe会自动调用传入的方法（render方法）。 demoindex12345678910111213141516171819202122232425import React from 'react';import ReactDOM from 'react-dom';import './index.css';import Btn from './component/btn';import Content from './component/content';import &#123;createStore&#125; from 'redux';import reducer from './redux/reducer';const store=createStore(reducer);const render=()=&gt;&#123; ReactDOM.render( &lt;div&gt; &lt;Content state=&#123;store.getState()&#125;/&gt; &lt;Btn ADDClick=&#123;()=&gt;store.dispatch(&#123;type:'ADD',count:2&#125;)&#125; ReduceClick=&#123;()=&gt;&#123;store.dispatch(&#123;type:'Reduce',count:2&#125;)&#125;&#125; /&gt; &lt;/div&gt; ,document.getElementById('root') );&#125;;render();store.subscribe(render); Reucer1234567891011const reducer=(state=0,action)=&gt;&#123; switch (action.type)&#123; case 'ADD': return state+action.count case 'Reduce': return state-action.count; default: return state; &#125;&#125;export default reducer; Content1234567891011import React,&#123;Component&#125; from 'react';export default class Content extends Component&#123; render()&#123; return( &lt;div&gt; &#123;`当前值为：$&#123;this.props.state&#125;`&#125; &lt;/div&gt; ) &#125;&#125; 中间件React生态非常完整，react的强大就在于它的生态。项目中常用的中间件都有现成的，我们只需要引用别人写好的包就可以。 applyMiddlewares()applyMiddlewares将中间件作为一个数组依次执行 123import logger from 'redux-logger';import thunk from 'redux-thunk';applyMiddleware(logger,thunk); 如何将方法添加到redux工作流程中？在创建store的时候将applyMiddlewares函数当作第二个参数 1const store=createStore(reducer,applyMiddleware(logger,thunk));]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx反向代理与负载均衡]]></title>
    <url>%2F2018%2F03%2F06%2Fnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[配置域名在C:\Windows\System32目录下搜索”hosts” 打开文件在文件中添加域名和ip格式是：IP 域名(127.0.0.1 www.myjd.com) 然后在nginx.conf当中进行一个配置 浏览器打开http://www.myjd.com 反向代理在我的机器上已经存在了127.0.0.1:1113和127.0.0.1:81两个网站现在我们将location中的配置进行修改，注释掉root，因为我们是反向代理，不需要root静态文件目录。需要添加一个proxy_pass代理选项后边值就是指向的地址。 重启nginx服务器 再去浏览器打开www.myjd.com,如果可以看到指向的地址的网站内容代表代理成功 负载均衡基础配置访问一个域名，将这个访问请求根据每个服务器负载，进行请求分发。 跨域访问允许所有外网访问需要在localtion中添加add_header ‘Access-Control-Allow-Origin’ ‘*’; 即可 注意’Access-Control-Allow-Origin’和’*’必须有空格分隔，不然会报错。 允许某一个外网访问在允许全部的基础上只需要吧*改成对应的域名即可 响应头写入信息在跨域请求头下面添加add_header并且设置相关信息即可，当对应的网站访问时就会写入到请求头当中。 配置二级目录可以在访问域名后加二级nginx将他执行其他服务 注意’/’的写法 If语句Nginx是支持if语句的 本段代码就是匹配移动端，当移动端访问时直接重定向到http://www.baidu.com重载nginx，浏览器切换到手机模式 Demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849worker_processes 4;events &#123; worker_connections 1024;&#125;#httpProxyModule#httpUpstremModulehttp &#123; include mime.types; default_type application/octet-stream; upstream zu1&#123;#变量名可以为任意 server localhost:1113; server localhost:81; server localhost:82 backup;#其他服务器无响应，那么又该标记的服务器接收请求 &#125; server &#123; listen 80; server_name www.myjd.com; location /json/ &#123; proxy_pass http://localhost:3004; &#125; location / &#123; #add_header 'Access-Control-Allow-Origin' '*';#是否可以通过外网访问我的域名 add_header 'Access-Control-Allow-Origin' 'http://www.abc.com';#可以设置为允许某一个站点访问 add_header 'num' '999'; #root html;#这里反向代理需要指向特定端口，所以我们不需要静态目录 proxy_pass http://zu1; if ( $http_user_agent ~* "(mobile|nokia|iPhone|ipad|android|samsung|htc|blackberry)")&#123; rewrite ^/$ http://www.baidu.com; break;#完成后，终止匹配，不在匹配后面的规则 &#125; index index.html index.htm; &#125; &#125; server &#123; listen 80; server_name www.a.com; location / &#123; add_header 'Access-Control-Allow-Origin' 'http://www.abc.com';#可以设置为允许某一个站点访问 add_header 'num' '999'; #root html;#这里反向代理需要指向特定端口，所以我们不需要静态目录 proxy_pass http://localhost:81; index index.html index.htm; &#125; &#125;&#125;]]></content>
      <categories>
        <category>NGinx</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NGinx安装]]></title>
    <url>%2F2018%2F03%2F05%2FNGinx%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[为什么要使用Nginx 1、使用更少的资源2、支持更多的并发连接3、更高的效率4、模块化配置，代码简洁&gt; 说明Nginx不擅长做cup密集型运算的动态请求，nginx适合做静态和反向，动态请求需要使用apache/tomcat去做。 NGinx安装windows安装下载地址：http://nginx.org/en/download.html 下载完成得到一个压缩包，将压缩包解压到D盘根目录下 在项目根目录下按住shift在空白处单击右键，选择”在此处打开命令行窗口”，进入命令行 打开命令行，我们需要将nginx和nginx.conf配置文件进行关联。 在这一步有很多电脑会报错”不能成功绑定”，80端口被占用。那么我们就需要修改nginx的配置文件，将80端口修改为8080。 现在我们重新启动，看到如下界面光标不断闪烁并且未报错，那么就代表启动成功。 在浏览器输入：http://127.0.0.1:8080/ 启动nginx命令：start nginx 浏览器访问：http://127.0.0.1:8080/ Nginx常见的命令 指令 说明 start nginx 启动nginx nginx -s stop 停止服务器 nginx -s quit 退出当前进程 nginx -s reload 重新加载配置 nginx -V 显示版本和配置信息 nginx -v 显示版本 nginx -t 测试配置 nginx -q 测试配置时，只输出错误信息]]></content>
      <categories>
        <category>NGinx</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017总结]]></title>
    <url>%2F2018%2F01%2F03%2F2017%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[楔子关于2017年的总结按理说应当要在2017末完成的，不知道为了什么事情一直拖到2018第二个上班日。工作两年多了,也许是我还没有养成职业习惯，做事情还没有做到提前做好充足的计划。所谓计划、执行，我有时候还是会没有方向的瞎折腾。一年过去了，我从2016年一个刚进入职场面试、入职都会紧张、脸红的不行的新人，到现在能够在职场游刃行走的老菜鸟，在职业技能和处事方式我得学到了很多，我的做事方式、处事方式以及我的性格都发生了不小的变化。 2017新掌握的技术Node.js Express Koa MySQL/MariaDB MongoDB/MongoOSE React 2017学习的书籍精益创业 Node.js权威指南 深入浅出Nodejs React全栈 编写可维护的JavaScript JavaScript高级程序设计 写这篇总结的目的我从高中毕业好像就没怎么写过东西了，人长大了感慨太多就变成了矫情，其实我并不是一个矫情的人。在去年在工作中有不足，在生活中也有一个很大很大的遗憾，写这篇总结没有太多具体的目的，就是想静下来和自己聊一聊天，聊一聊我们一起走过的经历，也是在审视自己，告诫自己不要再留任何遗憾。 工作中的不足2017年对我来说非常的关键和重要，2016年初我正式进入企业，进到过很多的科技公司，我也意识到自己在技术和做事方式有很大不足。2017我在这一年学了很多的技术，在技术栈的定义上我也从一个切图仔正式成为了一个大前端。说道这个前端两个字我有时候也是挺反感的，我不会刻意的标榜我自己是某一门技术的开发人员，我对自己的定义一直就是程序员。程序员的价值就是通过程序为企业创造价值，不管什么技术，能够创造价值，能够给我生活想要的我都会去学，其实我相信大部分做程序的人都知道程序员的乐趣就是不断学习，不断的接触和探索新的东西。正是由于我去年太刻意把大部分精力放在了学习技术上，也导致了我在年末的时候工作上主动性没能达到我的要求。还有就是我想推动公司技术的进步和迭代，这个过程很难。公司领导对于新技术需要考虑到产品的后期维护、同类型技术人员招聘难度、新技术人员薪资、新技术与其他开发人员的配合这些成本因素。2017没能推动技术的更新，我也相信企业的大方向一定是向前。 不将就如果真的是因为孤独才和一个人交往，那肯定不是爱情，我不能因为没人陪我聊天，没人陪我逛超市，没人陪我吃饭，就随便向自己妥协。我的爱情观不允许我将就。和自己不爱的人在一起，每天就像加班一样难受。你们之间连共同的话题都没有，你喜欢安静他喜欢酒吧这样喧闹的场景，两人之间没有话题可以聊，就像搭伙在一起过日子一样难受。如果两个人之间没有相互的喜欢，这样的爱情，是很磨人的，倒不如一个人过的轻松自在。不要轻易的走进一段感情，总希望自己遇到一个可以用每分每秒爱我的人，一个让自己变得更好的人，而不是一个不断消耗自己的人。我知道，周围朋友突然的关心也许会让你变得容易动摇，让你变得不相信爱情，甚至开始攀比或者变得格外功利。但是你一定要告诉自己，你不要把恋爱交给标准，不要交给焦虑，更不要交给妥协，你要交给爱情。那个人一定会某个地方出现，陪你去看北海道的雪，走过四下无人的街，和你一同走过人生的风雨，但是，你要等。 我看过一段自己很喜欢的话，以至于在爱情世界里我一直奉行的一句话。“我理想中的爱情不是交朋友，不是谁都可以的，如果等不到那个人，那么怎样都是孤独的，将就的孤独或许更可怕，我还有时间，所以，再等等你。”其实有些时候很多问题的答案第一反应都是对的，就好像是，小的时候，有人会问你，你长大了是要找一个自己喜欢的人在一起，还是找一个喜欢自己的呀？那时候我们第一反应给出的答案不就是“自己喜欢的人吗”？生活是场修行，爱情亦如此。我们都是普通的不能再普通的人，但我们有权利去决定自己的人生的样子，记得，要找一个相爱的人，希望你很好，有了他，更好。 总有人问，为什么你明明那么孤独，却还不肯将就？大概是因为听过村上春树说的一句话：“哪里会有人喜欢孤独，不过是不喜欢失望罢了”。当我们一个人吃饭，看着对面桌的小情侣为对方调酱添菜，会心生羡慕。 当我们一个人看电影，转过头隔壁的情侣依偎在一起分享爆米花，会感到孤单。一个人生活很孤独，但是跟不喜欢的人生活会更孤独啊。 我宁可孤单，也不违心；宁可抱憾，也不将就。真的，不是很喜欢很喜欢很喜欢的人就不要在一起，千万不要。一辈子那么长，我一定要找个喜欢的在一起才满足，不要因为我们现在的孤独而去选择将就。我们要相信，始终会有一个人出现在你面前，和你一日二人三餐四季。 目标希望能够在2018到2019攒够能在成都买房的首付。让生活慢下来，逐渐稳定下来，让生活更生活。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>总结，2017</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[connect-redis]]></title>
    <url>%2F2017%2F12%2F19%2Fconnect-redis%2F</url>
    <content type="text"><![CDATA[介绍connect-redis是一个由node_redis支持的Redis快速的会话存储。 安装1npm install connect-redis express-session 通过express-session储存到connect-redis,来创建一个RedisStore构造函数。 1234567var session = require('express-session');var RedisStore = require('connect-redis')(session);app.use(session(&#123; store: new RedisStore(options), secret: 'keyboard cat'&#125;)); 配置选项Redis客户端是必需的。一个redis客户端是必需的。现有的客户端可以直接使用客户端传递参数为您创建使用主机，端口，或插座参数。 client:现有客户机 host:Redis服务器主机名 port:Redis服务器端口 socket:Redis服务器套接字 url:Redis服务器URL网址 以下附加参数可能包括在内： ttl Redis session TTL:到期时间，以秒为单位。默认为session.maxAge（如果未设置）就是一天。 disableTTL：禁用设置TTL，键将保持在redis直到被其他方式替换 db：数据库索引，使用第几个数据库，默认为0。 pass Redis：数据库的密码 prefix 数据表前缀默认为“sess：” 自定义Redis客户端node_redis如果客户端支持相同的接口，则其他客户端将会工作。只要通过客户端实例作为client配置选项。已知的支持客户包括： ioredis - 增加了对Redis Sentinel和Cluster的支持 常问问题如何处理与Redis的丢失连接？默认情况下，当连接丢失时，node_redis客户端将自动重新连接。但在这段时间内可能会有请求。在表达中，可以处理这种情况的一种方式是在建立会话（检查是否存在req.session）之后包括“会话检查” ： 1234567app.use(session( /* setup session here */ ))app.use(function (req, res, next) &#123; if (!req.session) &#123; return next(new Error('oh no')) // handle error &#125; next() // otherwise continue&#125;)]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>Nodejs</tag>
        <tag>Nodejs负载均衡</tag>
        <tag>进程间session共享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PM2]]></title>
    <url>%2F2017%2F12%2F18%2Fpm2%2F</url>
    <content type="text"><![CDATA[PM2介绍PM2是具有内置负载平衡器的Node.js应用程序的生产过程管理器。它使您可以永久保持应用程序的活动状态，无需停机即可重新加载应用程序，并且可以方便常见的系统管理任务 在生产模式下启动应用程序非常简单： 1$ pm2 start app.js PM2不断受到1400多个测试的攻击。 官方网站：http：//pm2.keymetrics.io/ 适用于Linux、macOS、Windows平台。从Node.js 0.12开始所有的Node.js版本都开始支持PM2。 安装PM21$ npm install pm2 -g 启动应用程序1$ pm2 start app.js 现在，您的应用程序已被PM2程序守护、监控并保持永久生效。 监视PM2和应用程序要监视你的应用程序，只需输入 1$ pm2 register 更新PM21234//安装最新的PM2版本$ npm install pm2@latest -g//保存进程列表，退出旧的PM2并恢复所有进程$ pm2 update 主要特点命令概述1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//常用命令$ npm install pm2 -g //安装PM2$ pm2 start app.js //启动，守护进程和自动重启应用程序（Node）$ pm2 start app.py //启动，守护进程和自动重启应用程序（Python）$ pm2 start npm -- start //启动，守护进程并自动重新启动节点应用程序//集群模式（仅适用于Node.js）$ pm2 start app.js -i 4 //在集群模式下启动4个应用程序实例,它会负载平衡网络查询到每个应用程序$ pm2 reload all //零秒停机重新加载$ pm2 scale [app-name] 10 //将群集应用程序扩展到10进程//进程监视$ pm2 list //列出所有以PM2开始的进程$ pm2 monit //显示每个应用程序的内存和CPU使用情况$ pm2 show [app-name] //显示应用程序的所有信息//日志管理$ pm2 logs //显示所有应用程序的日志$ pm2 logs [app-name] //显示特定应用程序的日志$ pm2 logs --json //以JSON格式记录$ pm2 flush$ pm2 reloadLogs//进程状态管理$ pm2 start app.js --name ="api" //启动应用程序并将其命名为"api"$ pm2 start app.js -- -a 34 //启动应用程序并传递选项"-a 34"作为参数$ pm2 start app.js --watch //重新启动应用程序的文件更改$ pm2 start script.sh //启动bash脚本$ pm2 start app.json //启动在app.json中声明的所有应用程序$ pm2 reset [app-name] //重置所有计数器$ pm2 stop all //停止所有应用程序$ pm2 stop 0 //停止ID为0的进程$ pm2 restart all //重新启动所有应用程序$ pm2 gracefulReload all //以集群模式轻松地重新加载所有应用程序$ pm2 delete all //杀死和删除所有的应用程序$ pm2 delete 0 //删除ID为0的应用程序//启动/引导管理$ pm2 startup //检测init系统，在启动时生成并配置pm2启动$ pm2 save //保存当前进程列表$ pm2 resurrect //恢复以前保存的进程$ pm2 unstartup //禁用并删除启动系统$ pm2 update //保存进程，杀死PM2并恢复进程$ pm2 generate //生成一个示例json配置文件//部署$ pm2 deploy app.json prod setup //安装程序“prod”远程服务器$ pm2 deploy app.json prod //更新“prod”远程服务器$ pm2 deploy app.json prod revert 2 //将 “prod”远程服务器还原为2//模块系统$ pm2 module：generate [name] //生成名称为[name]的样本模块$ pm2 install pm2-logrotate //安装模块（这里是一个日志轮换系统）$ pm2 uninstall pm2-logrotate //卸载模块$ pm2 publish //增量版本，git push和npm发布 进程管理一旦应用程序启动，您可以轻松地列出和管理它们：列出所有运行的进程： 1$ pm2 list 管理您的流程非常简单： 123$ pm2 stop &lt;app_name|id|'all'|json_conf&gt;$ pm2 restart &lt;app_name|id|'all'|json_conf&gt;$ pm2 delete &lt;app_name|id|'all'|json_conf&gt; 为了确保它重新评估环境变量中声明的变量json_conf作为参数，并可选择您的自定义env名称（json_conf如果有的话）： 1$ pm2 restart &lt; json_conf &gt; [--env &lt; env_name &gt; ] 要获得有关特定进程的更多详细信息： 1$ pm2 describe &lt; id | app_name &gt; 负载平衡和零秒停机重新加载当使用-i &lt;instance_number&gt;选项启动应用程序时，将启用集群模式。 群集模式启动您的应用程序的&lt;instance_number&gt;实例，并在每个实例之间自动负载平衡HTTP / TCP / UDP。这可以根据可用的CPU数量来提高整体性能。 所有主要的Node.js框架和任何Node.js应用程序都能和PM2无缝支持，并且无需更改任何代码： 主要命令： 123$ pm2 start app.js -i max //根据有效CPU数目启动最大进程数目$ pm2 reload all //零秒重新加载所有$ pm2 scale &lt;app_name&gt; &lt;instance_number&gt; //增加/减少进程号码 CPU /内存监视 监测所有已启动的程序 1$ pm2 monit 日志设施实时显示指定进程或所有进程的日志。标准，原始，JSON和格式化输出可用。 1$ pm2 logs [ ' all ' | app_name | app_id] [--json] [--format] [--raw] 例子： 123456$ pm2 logs APP-NAME //显示APP-NAME日志$ pm2 logs --json //JSON输出$ pm2 logs --format //格式输出$ pm2 flush //刷新所有日志$ pm2 reloadLogs //重新加载所有日志 启动脚本生成PM2可以生成并配置一个启动脚本，以便在每次服务器重新启动时保持PM2和您的进程活动。 支持init系统，如：systemd（Ubuntu 16，CentOS，Arch），upstart（Ubuntu 14/12），launchd（MacOSx，Darwin），rc.d（FreeBSD）。 12345678//自动检测init系统+在服务器启动时生成并设置PM2启动$ pm2 startup//手动指定启动系统,可以是：systemd，upstart，launchd，rcd$ pm2 startup [platform]//在服务器启动时禁用并删除PM2引导$ pm2 unstartup 在重新启动时保存/冻结进程列表： 1$ pm2 save 模块系统PM2嵌入一个简单而强大的模块系统。安装模块非常简单： 1$ pm2 install &lt; module_name &gt; 以下是一些PM2兼容模块（由PM2管理的独立Node.js应用程序）： pm2-logrotate自动轮转PM2和应用程序管理的日志pm2-webshell在浏览器中公开一个功能齐全的终端pm2-server-monit监视你的服务器健康 Keymetrics监测 如果您使用PM2管理您的NodeJS应用程序，则Keymetrics可以轻松监控和管理跨服务器的应用程序。随意尝试一下： 发现PM2的监控仪表板]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>Nodejs</tag>
        <tag>Nodejs负载均衡</tag>
        <tag>Nodejs应用程序管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-MYSQL]]></title>
    <url>%2F2017%2F12%2F12%2Fnode-MYSQL%2F</url>
    <content type="text"><![CDATA[安装node-mysql1$ npm install mysql 建立连接推荐的建立连接的方式是这样的： 123456789101112131415var mysql = require('mysql');var connection = mysql.createConnection(&#123; host : 'example.org', user : 'bob', password : 'secret'&#125;); connection.connect(function(err) &#123; if (err) &#123; console.error('error connecting: ' + err.stack); return; &#125; console.log('connected as id ' + connection.threadId);&#125;); 但是，也可以通过调用查询来隐式建立连接： 1234567var mysql = require('mysql');var connection = mysql.createConnection(...); connection.query('SELECT 1', function (error, results, fields) &#123; if (error) throw error; // connected!&#125;); 可以根据你喜好来处理你的错误，任何一种方法都可能是合适的。任何类型的连接错误（握手或网络）都被视为致命错误，请参阅错误处理部分以获取更多信息。 连接可配置选项建立连接时，可以设置以下选项： 1、 host：您要连接的数据库的主机地址。（默认值： localhost）2、 port：连接主机的端口号。（默认值：3306）3、 localAddress：用于TCP连接的源IP地址。（可选）4、 socketPath：unix域套接字连接的路径。在使用时host 和port被忽略。5、 user：MySQL用户身份验证。6、 password：该MySQL用户的密码。7、 database：将要连接到的数据库的名称。8、 charset：连接的字符集。这在MySQL的SQL级别（如utf8_general_ci）中被称为“整理” 。如果指定了SQL级别的字符集（比如utf8mb4），那么将使用该字符集的默认排序规则。（默认值：’UTF8_GENERAL_CI’）9、 timezone：在MySQL服务器上配置的时区。这用于将服务器日期/时间值转换为JavaScript Date对象，反之亦然。这可以是’local’，’Z’或者是在形式+HH:MM或者偏移量上-HH:MM。（默认值：’local’）10、 connectTimeout：在初始连接到MySQL服务器期间发生超时之前的毫秒数。（默认值：10000）11、 stringifyObjects：将对象进行字符串化，而不是转换为值。见问题＃501。（默认值：false）12、 insecureAuth：允许连接到请求旧（不安全）身份验证方法的MySQL实例。（默认值：false）13、 typeCast：确定是否应将列值转换为本机JavaScript类型。（默认值：true）14、 queryFormat：自定义查询格式功能。见自定义格式。15、 supportBigNumbers：在数据库中处理大数字（BIGINT和DECIMAL列）时，应该启用此选项（默认：）false。bigNumberStrings：启用supportBigNumbers并bigNumberStrings强制大数字（BIGINT和DECIMAL列）始终以JavaScript String对象的形式返回（默认：）false。启用supportBigNumbers但留下bigNumberStrings禁用仅当它们不能准确地表示为字符串对象返回大数字的JavaScript Number对象 （当它们超过[-2 ^ 53，+ 2 ^ 53]范围这恰好），否则它们将被返回作为数对象。如果supportBigNumbers被禁用，该选项将被忽略。16、 dateStrings：强制日期类型（TIMESTAMP，DATETIME，DATE）作为字符串返回，而不是充满JavaScript Date对象。可以是true/ false或一个类型名称数组保持为字符串。（默认值：false）17、 debug：将协议详细信息打印到标准输出。可以是true/ false应该打印的数据包类型名称的数组。（默认值：false）18、 trace：生成堆栈轨迹Error以包含库入口的调用位置（“长堆栈轨迹”）。大多数通话的性能会受到轻微影响。（默认值：true）19、 multipleStatements：允许每个查询多个mysql语句。注意这一点，这可能会增加SQL注入攻击的范围。（默认值：false）在调用存储过程时需要设置为true。20、 flags：使用非默认连接标志的连接标志列表。黑名单也是可能的。有关更多信息，请检查 连接标志。21、 ssl：带有ssl参数的对象或包含ssl配置文件名称的字符串。请参阅SSL选项。 除了将这些选项作为对象传递外，还可以使用url字符串进行数据库链接。例如： 1var connection = mysql.createConnection('mysql://user:pass@host/db?debug=true&amp;charset=BIG5_CHINESE_CI&amp;timezone=-0700'); 注意：MYSQL会优先尝试将查询值解析为JSON，如果失败则假定为纯文本字符串返回。 SSL选项ssl在连接选项需要一个字符串或对象。给定一个字符串时，它使用一个预定义的SSL配置文件。包括以下配置文件： “Amazon RDS”：此配置文件用于连接到Amazon RDS服务器，并包含 https://rds.amazonaws.com/doc/rds-ssl-ca-cert.pem 和 https://s3.amazonaws.com/rds-downloads/rds-combined-ca-bundle.pem连接到其他服务器时，需要提供选项对象，格式与crypto.createCredentials相同。请注意，参数需要一个证书字符串，而不是证书的文件名。这是一个简单的例子： 123456var connection = mysql.createConnection(&#123; host : 'localhost', ssl : &#123; ca : fs.readFileSync(__dirname + '/mysql-ca.crt') &#125;&#125;); 您也可以不填写ssl直接连接到MySQL服务器，但不能正确提供合适的CA的信任。但这是不合法的操作。 12345678var connection = mysql.createConnection(&#123; host : 'localhost', ssl : &#123; // 不要这样做 // 正确设置你的ca来获取连接信任 rejectUnauthorized: false &#125;&#125;); 终止链接有两种方法可以结束连接。通过调用end()方法完成终止连接： 123connection.end(function(err) &#123; // 终止链接&#125;); 这将确保所有以前排队的查询仍然在发送 COM_QUIT数据包到MySQL服务器。如果COM_QUIT在发送数据包之前就已经发生致命错误，则会 向回调函数提供err参数，但连接将被终止。另一种结束连接的方式是调用destroy()方法。这将导致底层套接字的立即终止。此外destroy()保证没有更多的事件或回调将引发的连接。 1connection.destroy(); destroy()方法与end()方法不同，destroy()不需要回调参数。 连接池这个模块不是一个接一个地创建和管理连接，而是使用内置的连接池mysql.createPool(config)。 阅读有关连接池的更多信息。 直接使用连接池12345678910111213var mysql = require('mysql');var pool = mysql.createPool(&#123; connectionLimit : 10, host : 'example.org', user : 'bob', password : 'secret', database : 'my_db'&#125;); pool.query('SELECT 1 + 1 AS solution', function (error, results, fields) &#123; if (error) throw error; console.log('查询到的结果是: ', results[0].solution);&#125;); 集中连接可以集中连接以简化共享单个连接或管理多个连接的操作。 1234567891011var mysql = require('mysql');var pool = mysql.createPool(&#123; host : 'example.org', user : 'bob', password : 'secret', database : 'my_db'&#125;); pool.getConnection(function(err, connection) &#123; &#125;); 当你完成一个连接，只要使用指令connection.release()，就可以连接将返回到池，准备再次被别人使用。（使用完连接池的连接一定要关闭） 1234567891011121314var mysql = require('mysql');var pool = mysql.createPool(...); pool.getConnection(function(err, connection) &#123; // 使用连接 connection.query('SELECT something FROM sometable', function (error, results, fields) &#123; // 抛出查询过程中遇到的错误 if (error) throw error; // 这里可以得到查询结果 // 完成连接。 connection.release();//关闭连接，连接返回连接池 // 不要在这里使用连接，它已经返回到池中。 &#125;);&#125;); 如果要关闭连接并将其从连接池中删除，可以使用 connection.destroy()。连接池将在下一次需要时创建一个新的连接。连接是由连接池创建的。如果将连接池池配置为允许多达100个连接，如果只是使用5个连接，那么只生成5个连接。连接也采用循环的方式，连接从连接池的顶部被取出并返回到底部。当从池中检索到以前的连接时，会将ping数据包发送到服务器以检查连接是否仍然良好。 连接池选项连接池支持所有与连接相同的选项。当创建一个新的连接时，这些选项只是传递给连接构造函数。除了这些选项之外，池还可以接受一些附加功能： 1、 acquireTimeout：在连接获取期间发生超时的毫秒数。这与connectTimeout稍有不同，因为获取池连接并不涉及建立连接。（默认值：10000）2、 waitForConnections：当没有可用的连接并连接数到限制时。如果设置为true池将连接请求排队，并在有可用时调用它。如果设置为false，池会立即回拨错误。（默认值：true）3、 connectionLimit：一次创建的最大连接数。（默认值：10）4、 queueLimit：设置连接池中排队的最大连接请求数。如果设置为0，排队的连接请求的数量没有限制。（默认值：0） 连接池事件acquire从连接池中获取连接时，连接池池将发出一个事件。这是在连接完成所有获取活动之后，在连接被传递到代码的回调之前调用的。 123pool.on('acquire', function (connection) &#123; console.log('获取到连接！');&#125;); connection在池中connection建立新的连接时，池将发出一个事件。 123pool.on('connection', function (connection) &#123; connection.query('SET SESSION auto_increment_increment=1')&#125;); enqueueenqueue当排队等待可用连接时，池将发出一个事件 123pool.on('enqueue', function () &#123; console.log('等待可用的连接！');&#125;); Releaserelease连接释放回池时池将发出一个事件。 123pool.on('release', function (connection) &#123; console.log('连接被释放！');&#125;); 关闭连接池中所有的连接当你使用连接池时，你必须结束所有连接，否则Node.js事件循环将保持活动状态，直到MySQL服务器关闭连接。这通常是在脚本中使用连接池池或尝试正常关闭服务器时完成的。要结束池中的所有连接，请使用连接池池中的end方法： 123pool.end(function (err) &#123; // 关闭连接在连接池中的所有连接&#125;); 多主机连接poolclusterpoolcluster提供多个主机连接。 1234567891011121314151617181920212223242526272829303132333435363738// 创建一个连接池集群var poolCluster = mysql.createPoolCluster(); // 为连接池集群添加配置poolCluster.add(config); //使用自动名称添加配置poolCluster.add('MASTER', masterConfig); // 添加一个命名的配置poolCluster.add('SLAVE1', slave1Config);poolCluster.add('SLAVE2', slave2Config); // 删除配置poolCluster.remove('SLAVE2'); // 删除具体名称的节点配置poolCluster.remove('SLAVE*'); // 删除SLAVE开头的配置 //全部连接池组 poolCluster.getConnection(function (err, connection) &#123;&#125;); // MASTER连接池组poolCluster.getConnection('MASTER', function (err, connection) &#123;&#125;); //监听删除集群中的配置节点 poolCluster.on('remove', function (nodeId) &#123; console.log('节点: ' + nodeId+’已被删除！’);&#125;); // 可以使*进行匹配节点poolCluster.getConnection('SLAVE*', 'ORDER', function (err, connection) &#123;&#125;); //可以使用正则进行节点匹配 poolCluster.getConnection(/^SLAVE[12]$/, function (err, connection) &#123;&#125;); // 获取所有的节点连接池poolCluster.of('*').getConnection(function (err, connection) &#123;&#125;); var pool = poolCluster.of('SLAVE*', 'RANDOM');pool.getConnection(function (err, connection) &#123;&#125;);pool.getConnection(function (err, connection) &#123;&#125;);pool.query(function (error, results, fields) &#123;&#125;); //关闭所有的连接池集群的连接 poolCluster.end(function (err) &#123; // 所有连接池集群中的连接全部关闭了&#125;); poolCluster选项 1、 canRetry:如果true，PoolCluster会尝试连接失败时重新连接。（默认值：true）2、 removeNodeErrorCount：如果连接失败，节点的errorCount增加。当errorCount大于时removeNodeErrorCount，删除一个节点PoolCluster。（默认值：5）3、 restoreNodeTimeout：如果连接失败，则指定在进行另一次连接尝试之前的毫秒数。如果设置为0，则节点将被删除，而不会被重新使用。（默认值：0） defaultSelector：默认选择器。（默认值：RR） RR：交替选择一个。（轮循调度） RANDOM：通过随机函数选择节点。 ORDER：无条件选择可用的第一个节点。 123456var clusterConfig = &#123; removeNodeErrorCount ：1 ，// 连接失败时立即删除节点。 defaultSelector ：' ORDER ' &#125; ; var poolCluster = mysql.createPoolCluster （ clusterConfig ） ; 切换登录用户MySQL提供了一个changeUser命令，允许你在不关闭底层套接字的情况下改变连接的当前用户和其他方面： 1234connection.changeUser(&#123;user : 'john'&#125;, function(err) &#123; if (err) throw err;&#125;); 这个功能的可用选项是： 1、 user：新用户的名称（默认为前一个）。2、 password：新用户的密码（默认为前一个）。3、 charset：新的字符集（默认是前一个）。4、 database：新的数据库（默认为前一个）。这个功能有时候有用的副作用是这个函数也重置任何连接状态（变量，事务等）。此操作过程中遇到的错误被视为由该模块致命的连接错误。 服务器断开连接由于网络问题，服务器计时，服务器重新启动或崩溃，您可能会失去与MySQL服务器的连接。所有这些事件被认为是致命的错误，并将有err.code = ‘PROTOCOL_CONNECTION_LOST’。有关更多信息，请参阅错误处理部分。通过建立一个新的连接重新连接一个连接。一旦终止，现有的连接对象不能通过设计重新连接。使用Pool时，断开的连接将从池中移除，释放空间，以便在下一次getConnection调用时创建新连接。 执行查询最简单的形式。query()是.query(sqlString, callback)，其中第一个参数是SQL字符串，第二个是回调： 第一种方式：12345connection.query('SELECT * FROM `books` WHERE `author` = "David"', function (error, results, fields) &#123; // error:在查询中产生的错误 // results：是查询成功后的查询结果 // fields：将包含有关返回的结果字段的信息（如果有的话）&#125;); 第二种形式.query(sqlString, values, callback)来使用占位符值（请参阅转义查询值）： 12345connection.query （' SELECT * FROM`books` WHERE`author` =？'，[ ' David ' ] ，function （error ，results ，fields ） &#123; // 错误将是一个错误，如果在查询期间发生的一个 // 结果将包含查询的结果 // 字段将包含有关返回的结果字段的信息（如果有的话）&#125; ） ; 第三种形式.query(options, callback)在查询中使用各种高级选项（如转义查询值， 具有重叠列名称的联接， 超时和类型转换） 123456789connection.query(&#123; sql: 'SELECT * FROM `books` WHERE `author` = ?', timeout: 40000, // 40s values: ['David']&#125;, function (error, results, fields) &#123; // 错误将是一个错误，如果在查询期间发生的一个 // 结果将包含查询的结果 // 字段将包含有关返回的结果字段的信息（如果有的话）&#125;); 转义查询为了避免SQL注入攻击，在SQL查询中使用数据之前，应该始终转义任何用户提供的数据。你可以这样做使用 mysql.escape()，connection.escape()或pool.escape()方法： 123456var userId = 'some user provided value';var sql = 'SELECT * FROM users WHERE id = ' + connection.escape(userId);connection.query(sql, function (error, results, fields) &#123; if (error) throw error; // ...&#125;); 或者，您可以使用?字符作为您想要像这样转义的值的占位符： 1234connection.query('SELECT * FROM users WHERE id = ?', [userId], function (error, results, fields) &#123; if (error) throw error; // ...&#125;); 多个占位符以与传递相同的顺序映射到值。例如，在下面的查询fooequals a，barequals b，bazequals c和 id将是userId： 1234connection.query('UPDATE users SET foo = ?, bar = ?, baz = ? WHERE id = ?', ['a', 'b', 'c', userId], function (error, results, fields) &#123; if (error) throw error; // ...&#125;); 这看起来类似于MySQL中的预处理语句，但它实际上只是在connection.escape()内部使用相同的方法。 注意事项 所有?语句都能被替换，即使是注释和字符串中包含的语句也是如此。 不同的值类型有不同的转义，这里是： 1、 数字保持不变2、 布尔转为true/false3、 日期对象转换为’YYYY-mm-dd HH:ii:ss’字符串4、 缓冲区被转换为十六进制字符串，例如 X’0fa5’5、 字符串安全地逃脱6、 数组变成列表，例如[‘a’, ‘b’]变成’a’, ‘b’7、 嵌套数组变成分组列表（用于批量插入），例如[[‘a’, ‘b’], [‘c’, ‘d’]]变成(‘a’, ‘b’), (‘c’, ‘d’)8、 具有toSqlString方法的对象将.toSqlString()被调用，并将返回的值用作原始SQL。9、 对象key = ‘val’对于对象上的每个可枚举属性都是成对的。如果属性的值是一个函数，则跳过它; 如果该属性的值是一个对象，则调用toString（）并使用返回的值。10、 undefined/ null被转换为NULL11、 NaN/ Infinity保持原样。MySQL不支持这些，试图插入它们作为值将触发MySQL错误，直到他们实现支持。 这个转义允许你做这样的整洁的事情： 1234567var post = &#123;id: 1, title: 'Hello MySQL'&#125;;var query = connection.query('INSERT INTO posts SET ?', post, function (error, results, fields) &#123; if (error) throw error; // Neat!&#125;);console.log(query.sql);// INSERT INTO posts SET `id` = 1, `title` = 'Hello MySQL' 转义查询标识符如果因为它是由用户提供的，你不能相信一个SQL标识符（数据库/表/列名），你应该避面mysql.escapeId(identifier)，connection.escapeId(identifier)或者pool.escapeId(identifier)： 123456var sorter = 'date';var sql = 'SELECT * FROM posts ORDER BY ' + connection.escapeId(sorter);connection.query(sql, function (error, results, fields) &#123; if (error) throw error; // ...&#125;); 它也支持添加合格的标识符。它会逃脱这两个部分。 123var sorter = 'date';var sql = 'SELECT * FROM posts ORDER BY ' + connection.escapeId('posts.' + sorter);// -&gt; SELECT * FROM posts ORDER BY `posts`.`date` 如果您不想将其.视为限定标识符，则可以将第二个参数设置true为将字符串保留为文字标识符： 123var sorter = 'date.2';var sql = 'SELECT * FROM posts ORDER BY ' + connection.escapeId(sorter, true);// -&gt; SELECT * FROM posts ORDER BY `date.2` 或者，您可以使用??字符作为您希望像这样转义的标识符的占位符： 12345678var userId = 1;var columns = ['username', 'email'];var query = connection.query('SELECT ?? FROM ?? WHERE id = ?', [columns, 'users', userId], function (error, results, fields) &#123; if (error) throw error; // ...&#125;); console.log(query.sql); // SELECT `username`, `email` FROM `users` WHERE id = 1 注意，这最后一个字符序列是实验性的，语法可能会改变当你传递一个Object，.escape()和.query()、.escapeId()是用来避免在对象键中进行SQL注入。 准备查询你可以使用mysql.format准备一个带有多个插入点的查询，利用正确的转义ID和值。一个简单的例子如下： 123var sql = "SELECT * FROM ?? WHERE ?? = ?";var inserts = ['users', 'id', userId];sql = mysql.format(sql, inserts); 在此之后，您将获得有效的转义查询，然后您可以安全地将其发送到数据库。如果您希望在将查询发送到数据库之前准备查询，这非常有用。由于mysql.format是从SqlString.format公开的，你也可以选择（但不是必须的）传入stringifyObject和timezone，允许你提供一个把对象转换成字符串的自定义方式。 获取插入行的ID如果使用自动增量主键将一行插入表中，则可以像这样检索插入标识： 1234connection.query('INSERT INTO posts SET ?', &#123;title: 'test'&#125;, function (error, results, fields) &#123; if (error) throw error; console.log(results.insertId);&#125;); 获取受影响行数您可以从插入，更新或删除语句中获取受影响的行数。 1234connection.query('DELETE FROM posts WHERE title = "wrong"', function (error, results, fields) &#123; if (error) throw error; console.log('deleted ' + results.affectedRows + ' rows');&#125;) 获取更改的行数1234connection.query('UPDATE posts SET ...', function (error, results, fields) &#123; if (error) throw error; console.log('changed ' + results.changedRows + ' rows');&#125;) 获取连接ID1234connection.connect(function(err) &#123; if (err) throw err; console.log('connected as id ' + connection.threadId);&#125;); 并行执行查询MySQL协议是顺序的，这意味着你需要多个连接来并行执行查询。您可以使用Pool来管理连接，一个简单的方法是为每个传入的http请求创建一个连接。 流式查询有时您可能需要大量的回调嵌套。您这可以这样做： 123456789101112131415161718var query = connection.query('SELECT * FROM posts');query .on('error', function(err) &#123; // 查询过程中产生的错误 &#125;) .on('fields', function(fields) &#123; &#125;) .on('result', function(row) &#123; // 查询到的结果 connection.pause(); processRow(row, function() &#123; connection.resume(); &#125;); &#125;) .on('end', function() &#123; // 关闭连接 &#125;); 用流管道结果查询对象提供了.stream([options])将查询事件封装到可读流 对象中。这个流很容易被传递到下游管道，并提供自动暂停/恢复，基于下游拥塞和可选highWaterMark。objectMode流的参数被设置为true和不能被改变（如果你需要一个字节流，你需要使用一个变换流，例如objstream）。例如，将管道查询结果导入另一个流（最大缓冲区为5个对象）只是简单的： 123connection.query('SELECT * FROM posts') .stream(&#123;highWaterMark: 5&#125;) .pipe(...); 多语句查询对于多个语句的支持由于安全原因被禁用（如果值未正确转义，则允许SQL注入攻击）。要使用此功能，您必须为您的连接启用它： 1var connection = mysql.createConnection(&#123;multipleStatements: true&#125;); 你可以查询多条SQL语句并且输出多个语句的查询结果 123456789var query = connection.query('SELECT 1; SELECT 2'); query .on('fields', function(fields, index) &#123; // 后面的结果行的字段 &#125;) .on('result', function(row, index) &#123; // 索引指这个结果所属的语句（从0开始） &#125;); 存储过程您可以像查询任何其他mysql驱动程序一样从查询中调用存储过程。如果存储过程生成多个结果集，则它们将以与多个语句查询的结果相同的方式显示给您。 1234567891011121314var conn=mysql.createConnection(&#123; host:'127.0.0.1', user:'root', password:'root_pwd', database:'db_name', multipleStatements:true&#125;);conn.connect(()=&gt;&#123; var sql="CALL insertUser('tom:'123',@result)";SELECT @result; conn.query(sql,(err,result)=&gt;&#123; if(err)throw err; console.log(result); &#125;)&#125;) 超时每个操作都有一个可选的不活动超时选项。这使您可以指定适当的操作超时。需要注意的是，这些超时不是MySQL协议的一部分，而是通过客户端的超时操作。这意味着当超时达到时，发生的连接将被破坏，不能进行进一步的操作。 123456789101112// 60秒后杀死查询connection.query(&#123;sql: 'SELECT COUNT(*) AS count FROM big_table', timeout: 60000&#125;, function (error, results, fields) &#123; if (error &amp;&amp; error.code === 'PROTOCOL_SEQUENCE_TIMEOUT') &#123; throw new Error('计算行数太长!'); &#125; if (error) &#123; throw error; &#125; console.log(results[0].count + ' rows');&#125;);]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>Nodejs</tag>
        <tag>数据库</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebWorkers]]></title>
    <url>%2F2017%2F09%2F25%2FWebWorkers%2F</url>
    <content type="text"><![CDATA[Web Workers概念Web Workers是一种机制，通过它可以使一个脚本运行在与Web应用程序的主线程相互分离的后台线程中运行。这样做的优点是可以在单独的线程中执行繁琐的处理，让主线程运行不被阻塞/减慢。 普通的js是单线程，由于普通js是解释执行，如果js脚本执行报错就会阻塞剩余js脚本的执行，当前以后的js停止执行。Web Workers是多线程，即使是js其中一个线程报错，也不会影响其他线程执行。 Web Workers描述一个worker是使用构造函数创建的一个对象（例如,Worker()）, 运行一个命名的 JavaScript文件—这个文件包含了将在 worker 线程中运行的代码，并且 worker在与当前window不同的另一个全局上下文中运行。 主线程和 worker 线程之间通过这样的方式互相传输信息：两端都使用 postMessage()方法来发送信息, 并且通过onmessage 这个 event handler来接收信息。（传递的信息包含在Message这个事件的数据属性内) 。数据的交互是通过传递副本，而不是直接共享数据。 一个 worker 可以生成另外的新的 worker，这些 worker 的宿主和它们父页面的宿主相同。 此外，worker 可以通过 XMLHttpRequest 来访问网络。 Web Workers不能使用的API你可以在你的 worker 线程中运行任意的代码，以下情况除外：你不能直接在 worker 线程中操纵 DOM 元素（不能使用DOM API）, 或者使用某些window对象中默认的方法和属性。 Web Workers可以使用的API但是 window 对象中很多的方法和属性你是可以使用的，包括 WebSockets，以及诸如 IndexedDB 和 FireFox OS 中独有的 Data Store API 这一类数据存储机制。 Web Workers API接口 1 检查浏览器是否支持浏览器2 创建Worker对象 方法 postMessage（data）方法 - 传递消息 terminate（方法） - 终止通信 事件 *onmessage事件 - 监听Worker Worker单向通信 index.html1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt; &lt;input type="button" value="开始" id="start"&gt; &lt;input type="button" value="停止" id="stop"&gt; &lt;br&gt; &lt;div id="show"&gt;&lt;/div&gt; &lt;script&gt; //定义全局Worker var worker; //完成需求 var start=document.getElementById("start"); var show=document.getElementById('show'); start.onclick=function()&#123;//操作Worker //1.表示当前浏览器是否支持Worker if(typeof(Worker!="undefined"))&#123; //表示当前浏览器支持Worker /*2.创建Worker对象，指定Worker文件 *相当于已经开始调用Worker文件中的逻辑 */ worker=new Worker("Worker1.min.js"); /* 3.为worker对象绑定onmessage事件 作用 - 监听Worker文件逻辑执行 触发 - postMessage（）方法被调用 */ worker.onmessage=function(event)&#123; /* * 接收到Worker文件传递的消息 * 通过绑定事件的处理函数的event对象 * 事件对象 * 集成了data属性 - 就是传递回来的消息 */ show.innerHTML=event.data; &#125; &#125;else&#123; //表示当前浏览器不支持Worker，给出错误提示 &#125; &#125; var stop=document.getElementById('stop'); stop.onclick=function()&#123; //终止Worker通信 worker.terminate(); &#125; &lt;/script&gt;&lt;/body&gt; worker01.js 123456789101112131415/** 该文件就是一个文件Worker文件-其实就是JS文件* 该文件具有一个上下文环境 - Worker对象* 在Worker文件中，可以直接使用Worker对象的方法和事件* 完成计数逻辑* */var num=0;function addNum()&#123; //将计数的值传递回HTML页面 postMessage(num); //累加计数 num++; setTimeout(addNum,1000);&#125;addNum(); Worker双向通信 index.html123456789101112131415161718192021222324252627&lt;body&gt;&lt;input type="text" id="data"/&gt;&lt;input type="button" id="btn" value="发送"/&gt;&lt;br/&gt;&lt;div id="show"&gt;&lt;/div&gt;&lt;script&gt; var btn=document.getElementById('btn'); btn.onclick=function()&#123;// 1.获取用户输入的信息 var data=document.getElementById("data").value;// 2.将信息发送给worker文件// a.创建worker对象 if(typeof(Worker!="undefined"))&#123; var worker=new Worker('01.js');// b.通过worker对象的postMessage()传递消息 worker.postMessage(data); worker.onmessage=function(event)&#123; var value=event.data; var show=document.getElementById('show'); show.innerHTML="&lt;h3&gt;"+value+"&lt;/h3&gt;" &#125; &#125;else&#123; &#125; &#125;&lt;/script&gt;&lt;/body&gt; worker.js123456789101112addEventListener('message',function(event)&#123; var value=event.data;// 模拟对话 switch(value)&#123; case "i am zhangwuji": postMessage("hello,i am xiaona."); break; case "Hello,xiaona": postMessage("i am happy"); break; &#125;&#125;);]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>WebWorkers</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[启动Angular应用]]></title>
    <url>%2F2017%2F09%2F22%2F%E5%90%AF%E5%8A%A8Angular%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[我们打开项目根目录的.angular-cli.json文件，里边有apps的一个数组，里边定义了项目模块的根路径root：src。它直接指向了项目根目录的SRC文件夹，项目一旦启动，Angular-CLI就会监视SRC目录下的所以文件资源。 启动时加载了哪个页面？启动时加载了那些脚本？.angular-cli.json文件的apps数组还定义了有index属性和main属性，我们在启动Angular项目时主HTML就是index属性对应的index.html，主脚本是main属性对应的main.ts，主样式表是styles属性对应的styles.css。 这些脚本做了什么事？Main.ts ① 从Angular核心模块中导入enableProdMode，用于关闭Angular的开发者模式。② 这个方法告诉Angular使用哪个模块启动整个应用。③ 导入主模块④ 导入环境配置⑤ 判断当前是一个生产环境，就调用enableProdMode关闭开发者模式。⑥ 调用.bootstrapModule方法，传入AppModule作为启动模块，来启动应用（这是整个程序的起点）。 app.module.ts 加载app.module.ts时会加载依赖的模块imports属性里的模块。加载完成后并且会分析依赖模块所依赖的包。直到加载完所有所需要的依赖。 加载完成后Angular会在index.html中，寻找启动模块指定的主组件对应的css选择器。也就是app.module中bootstrap:主组件对应的css选择器（app.component.ts中的selector:’app-root’）。使用templateURL中的内容替换app-root标签中的内容。 启动Angular应用添加npm的脚本命令]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>启动Angular应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Angular开发环境]]></title>
    <url>%2F2017%2F09%2F22%2F%E6%90%AD%E5%BB%BAAngular%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[安装NodeJS、Angular CLI、WebStorm安装Node.js进入官网：https://nodejs.org/en/ 下载安装包，官网会根据用户系统推荐下载不同版本的node.js安装包（本机是Windows X64，下载稳定版（LTS）和尝鲜版（Current）都可以）。 安装Node.js安装包（双击下载的安装包，默认安装或自定义安装都可以） 验证安装: –&gt; Node.js安装完成在命令行会多出一个npm命令，命令行输入npm -v输出npm版本号，说明node.js安装成功。 安装Angular-CLI命令行输入： 1$ sudo npm install -g @angular/cli 命令行就会自动安装（注意安装Angular-CLI前必须先安装Node.js）。 安装完成后可以使用指令查看安装结果： 1$ ng -v 安装WebStorm下载地址：http://www.jetbrains.com/webstorm/安装步骤和node.js一样。 使用Angular CLI创建并运行Angular项目创建项目在项目根目录下输入命令行命令： 1$ ng new '项目名字' //比如：ng new auction 执行完命令后，在在当前目录下生成一个名为auction的项目文件。 注意：通过Angular-CLI生成的项目，项目文件和目录不能随意改变 项目目录结构介绍 . e2e ————————————端到端的测试目录. src ————————————-应用源代码目录. .gitignore—————————–这是git的一个文件（与项目无关）. .angular-cli.json——————–Angular命令行工具的配置文件. Karma.conf.js———————–单元测试的执行器. Package.json————————npm配置文件. Protracor.conf.js——————–和karma类似也是一个自动化测试工具. README.md————————-Angular-CLI命令说明. Tslint.json—————————–定义TypeScript代码检查的规则 . app——————————包含我们的组件和模块. assets—————————空文件夹，存放静态资源的比如：图片. environments—————–环境配置（Angular支持多环境开发，生成环境、开发环境、测试环境）. favicon.ico———————图标文件. index.html———————根HTML. main.ts————————-整个Web应用的入口点（脚本执行的入口点）. polyfills.ts———————-导入一些必要的库（让Angular能够运行在一些老版本浏览器中）. styles.css————————存放全局样式. test.ts—————————-自动化测试. tsconfig.app.json————–TypeScript编译器的配置. tsconfig.spec.json————–TypeScript编译器的配置 . app.module.ts————————模块. app.component.ts——————-组件. app.component.spec.ts————–组件 Component介绍 装饰器（@Component）Component装饰器用来告知Angular框架，如何处理一个TypeSCript类。Component装饰器包含多个属性，这些属性的值叫做源数据。Angular会根据这些源数据的值来渲染组件，并执行组件的逻辑。 模板（Template）根据模板定义组建的外观，模板一HTML的形式存在，告诉Angular如何来渲染组件。一般来说模板很像HTML，但是我们可以再模板中使用Angular数据绑定语法，来呈现控制器中的数据。 控制器（Controller）就是一个简单的TypeScript类，他靠Component装饰器来装饰。控制器会包含组件所有的属性和方法（绝大多数页面逻辑）。控制器通过数据绑定与模板通讯。 输入属性（@Inputs( )）用于接收外部传入的数据，输入属性使得父组件可以直接传值给子组件。 提供器（providers）用于做依赖注入的 生命周期钩子（Lifecycle Hooks）从一个组件创建到销毁的这个过程中，有多个钩子可用来触发、执行各种业务逻辑。 样式表（Styles）组件可以关联一些样式表文件，来提供一些组件专用的样式。 动画（Animations）Angular提供了一个动画包来帮助我们，方便的创建组件相关的动画效果。比如：淡入淡出。 输出属性（@Outputs）与输入属性相对，用于定义其他组件可能会感兴趣的事件，或者要用来在组件间共享数据。]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>搭建Angular开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular4.0程序架构]]></title>
    <url>%2F2017%2F09%2F22%2FAngular4-0%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1、整体架构：Angular App代表整个Angular应用，用户会与应用做交互。Angular本身是一个客户端框架，开发出来的都是客户端程序，所以客户端程序会与服务器做交互，从服务器获取数据或者给服务器传递数据。2、Angular应用架构：Angular应用（Angular app）至少包含一个模块（NgModule）和一个组件（component）。3、组件：component是Angular应用的基本构建块，你可以你一个组件理解为一段带有业务逻辑和数据的HTML。组件之间可以有父子关系，一个父组件可以包含多个子组件。组件可以调用服务（service）4、服务：服务（service），用来封装可重用的业务逻辑（比如：在商品详情页、订单详情页，获取商品信息的逻辑（共用））。服务之间也可以相互调用。5、指令：允许你向HTML元素添加自定义行为。6、模块：模块（NgModule）用来将应用中不同的部分组织成一个Angular框架可以理解为单元。 注意：组件、服务、指令是实现功能的，模块是打包、分发这些功能的。]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>Angular4.0程序架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular4.0简介]]></title>
    <url>%2F2017%2F09%2F21%2FAngular%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Angular VS AngularJSAngularJS的优点 1、模板功能非常强大（丰富的angular指令，使angular拥有了双向数据绑定能力）2、比较完善的前端MVC框架（包含了模板、双向数据绑定、路由、模块化、服务、过滤器、依赖注入等）3、引入了Java的一些概念（比如依赖注入、单元测试等） AngularJS的问题 1、性能（双向数据绑定是一把双刃剑、随着组件的增加，项目越来越复杂，双向数据绑定（脏检查，每一次数据变化都会触发脏检查）会带来性能问题）2、路由（ng-view只能有一个，不能嵌套多个视图，虽然有第三方的ui-router但是依然不是很灵活，他还是一个第三方模块，不是框架本身）。3、作用域（angularjs执行环境和浏览器环境隔离开，所有原生事件都不能影响angularjs作用域，比如不能使用原生click事件，必须使用ng-click指令。$scope在Angular中已经去掉了，任何原生事件都能被执行和处理。）4、表单验证（表单验证功能非常薄弱，需要写大量的模板标签。在Angular中使用全新的表单API，尤其是响应式表单，非常方便的进行复杂校验，并显示错误信息。）5、JavaScript语言（JavaScript没有类型系统，面向对象开发能力不足。Angular中使用TypeScript语言开发，他是ES6语言的一个超集，带有完善的类型系统，让我们在编译阶段解决一部分bug，从而使运行时的bug减少。还可以在IDE中获得提示支持，和更快的性能。）6、学习成本（学习成本高，需要学习控制器、指令、作用域、模板、数据绑定、链式函数、过滤器、依赖注入等等） Angular新特性 1、全新的命令行工具AngularCLI（是Angular官方提供的一个命令行工具，提供了很多方便的功能帮助我们进行开发，比如：搭建项目脚手架、生成新组件的基础代码、作为一个开发服务器进行、调试、编译、构建代码、运行自动化的单元测试等等。）2、服务器端渲染（比如：需要10s才能加载完的单页应用程序，在1s之内呈现在用户面前。其次他可以针对每个单页应用每个视图去做SEO搜索引擎优化。）3、移动和桌面兼容（在AngularJS中就有所体现，在Angular中借助ionic、nativeScript有提高到了新的高度。Angular官方还提供了一个UI库叫Angular Material。） AngularJS架构Angularjs是一个典型的MVC架构 Angular架构在Angular中采用了一个完全不同的架构，在Angular中整个应用就是一个组件树，用户看到的页面就是有几个被激活的组件组成的。 Angular VS React速度React：速度与其他框架相比React采用完全不同的Dom渲染方式，也就是虚拟DOM。由于采用虚拟DOM技术，React只在调用setState的时候会更新DOM，而且还是先更新虚拟DOM，然后和实际的DOM比较，再更新实际的DOM。这个方式与AngularJS比较是更新次数少，每次更新的数据少，导致了他的速度非常快。;Angular：采用和React非常类似的方法，实现了一个新的变更检测算法，在速度上已经和React不相上下。 Flux架构React：Reatc更关注UI的组件化，和数据的单向更新。提出了一个Flux的新概念。而且在React中可以直接使用js的ES6语法，然后通过webPack之类的工具编译成浏览器兼容的ES5。Angular:在AngularJS中是不支持的，但是在Angular中，比如：组件化、单向更新、ES6语法支持都已经实现了。 服务器渲染React：可以在服务器端预渲染应用，在发送给客户端。他可以在预渲染的静态内容中，恢复一样记录到动态应用程序中。Angular：在AngularJS中不支持，Angular已经支持。 Angular VS Vue简单：Vue：Vue的目标就是通过尽可能简单的API，实现响应的数据绑定，和组合的视图组件。而且Vue是国内大牛开发，文档都是中文的，而且非常完善，所以在学习和使用的难度上都不是很高，很容易上手。 灵活：Vue:Vue官方提供了一个构建工具，来协助你构建效果，但是并不限制你如何构建Angular：Angular-CLI包办了一切非开发时的工作，比如：编译、构建等。 性能：Vue：Vue的尺寸非常小，只有10+K，使用了类React虚拟DOM的方式来处理组件，速度很快，性能很好。Vue是一个优秀的前端框架，但是在选择他时，是需要注意和考虑的。Angular：Angular基本的框架就要50+k 主导：Vue:是个人主导的一个项目，Vue的社区和生态与Angular存在差距。Angular：由Google主导，并且使用的是微软开发的TypeScript语言（团队项目更靠谱）。比如社区和生态环境的区别，Angular在全球范围内拥有庞大的开发者社区和配套的生态环境。 只关注WEBVue：Vue是只关注WEB的一个框架，Angular：作为框架而言Angular实现了更高层次的抽象，他是一个大的前端的一个平台，他不仅可以开发WEB项目（面向DOM），还可以开发客户端应用（面向IOS、安卓Native的应用，比如：NativeScript） 服务器端渲染：Vue：Vue目前只能靠第三方的库或服务来实现。Angular：Angular有官方提供的服务器端渲染支持，可以解决Vue这种纯前端框架不能解决的一些痛点。]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>Angular4.0</tag>
        <tag>Angular VS React</tag>
        <tag>Angular VS vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs数据加密解密]]></title>
    <url>%2F2017%2F08%2F20%2FNodejs%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[加密和安全计算机在网络通信过程中，需要经常用到数据加密技术以实现如下三个方面的目的： （1）数据保密使用各种加密算法把数据进行加密，之后才可以进行公开的数据传输而不会被造成数据外泄（2）数据完整性验证加密算法可以对数据进行摘要计算生成验证码，已验证数据在传输过程中是否被修改过；（3）身份认证使用加密算法可以生成数组签名，以实现对特定主机身认证，防止目标主机什么被冒用。 SSL和OpenSSLSSL:Secure Socket Layer ,安全套阶层协议，可以在Internet上提供保密性数据传输。Netscape公司在推出第一个Web浏览器的同时，提出了SSL协议标准。其目标是保证两个应用通信的保密性和可靠性，可在服务器和用户端同时支持；目前已经成为Internet上保密通讯的工业标准。 Eric A. Young和Time J. Hudson自1995年开始使用C语言编写名为OpenSSL软件包，这是一个开放源代码的软件包。1998年，OpenSSL项目组开始接管OpenSSL的开发工作；到目前为止，OpenSSL软件包的算法已经非常完善，支持SSL2.0，SSL3.0以及TLS1.0协议。 OpenSSL整个软件包大概可以分成三个主要的功能部分： 密码算法库 SSL/TLS协议工具库 辅助应用程序 其中的密码算法库对如下几个方面的算法进行了实现： 信息摘要 对称加密 非对称加密 密钥证书管理 crypto模块Node.js中提供的crypto模块对OpenSSL提供的工具函数进行了进一步的封装，可以很方便的进行消息摘要计算、数据加密和解密、以及数字签名生产及验证。使用crypto.getHashes( )可以查看该模块提供的所有哈希算法（也称为散列算法或消息摘要算法），如sha1、md5等。使用crypto.getCiphers( )可以查看该模块提供的所有的加密算法，如des、blowfish等； 哈希算法哈希算法：也称为散列算法、消息摘要算法，将任意长度的二进制数据映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。哈希值是一段数据唯一且极其紧凑的数值表示形式。如果散列一段明文而且哪怕只改该段落的一个字母，随后的哈希都将产生不同的值。要找到散列为同一个值得两个不同的输入，在计算上是不可能的，所以数据的哈希值可以检验数据的完整性。一般用于快速查找和加密算法。 常见的哈希算法有： sha1 sha256 md5 ripemd160 哈希算法对象要进行消息散列，可以使用createHash( )方法创建一个哈希算法对象： 12var hash=crypto.createHash(algorithm)//参数为要使用的哈希散列算法名称 创建hash对象后，可以使用该对象的update( )方法追加要进行散列计算的摘要数据，该方法可以先后追加多次数据。123hash.update(data,[input_encoding])//data是要进行散列计算的数据，可以是Buffer或String对象//encoding指定摘要内容所使用的编码格式，如utf8、ascii、binary等 最后使用hash对象的digest( )方法输出最终的散列数据：12hash.digest([encoding])//encoding为要输出的摘要的编码格式，如hex、binary、base64等 哈希算法示例下面是一个完整使用哈希做算法的示例，把一个指定文件中的数据进行哈希散列，得到唯一的一段消息摘要数据：1234567891011const crypto=require('crypto');const fs=require('fs');var hash=crypto.createHash('md5');var input=fs.createReadStream('index.js');input.on('data',(data)=&gt;&#123; hash.update(data);&#125;)input.on('end',()=&gt;&#123; var result=hash.digest('hex'); console.log(result);&#125;); HMAC算法HMAC:Hash-based Message Authentication Code，密钥相关的哈希运算消息认证码，HMAC运算利用哈希算法，一个密钥和一个消息为输入，生成一个消息摘要为输出。 该算法与哈希算法的不同点在于进行消息散列运算时，添加了一个密钥，以防止对签名完整性的破坏。 HMAC算法对象要进行HMAC算法，可以使用createHmac( )方法创建一个算法对象： 123var hmac=crypto.createHmac(algorih,key);//algorithm为要使用的哈希散列算法名称//Key为密钥 创建hmac对象后，可以使用该对象的update( )方法追加要进行散列计算的摘要数据，该方法可以先后追加多次数据： 12hmc.update(data)//data是要进行散列计算的数据，可以是Buffer或String对象 最后使用hmc对象的digest( )方法输出的散列数据： 12hmac.digest([encoding])//encoding为要输出的摘要的编码格式，如hex、binary、base64等 HMAC算法示例下面是一个完整使用哈希算法的示例，把一个指定文件中的数据进行哈希散列，得到唯一的一段消息摘要数据：123456789101112const crypto=require('crypto');const fs=require('fs');var secret='my-secret-123'var hmac=crypto.createHmac('md5',secret);var input=fs.createReadStream('index.js');input.on('data',(data)=&gt;&#123; hash.update(data);&#125;)input.on('end',()=&gt;&#123; var result=hmac.digest('hex'); console.log(result);&#125;); 对称加密和非对称加密技术对称加密技术：对数据进行加密和解密使用相同的密钥。非对称加密技术：需要成对出现的公钥和私钥；如果用公开密钥对数据加密，只有用对应的私有才能解密；如果用私钥对数据进行加密，只有用对应的公开密钥才能解密。 Crypto模块提供了四个加密相关类： Cipher：用于数据加密 Decipher：用于数据解密 Sign：使用私钥生成用户签名 Verify：使用公钥验证用户签名 对称加密要进行数据加密，必须创建Cipher类的对象：123var cipher=crypto.createCipher(algorithm,key);//algorithm为要使用的加密算法，如blowfish、des、seed等//key为使用的密钥 使用加密对象的update( )方法追加指定要加密的数据；1234cipher.update(data,[input_encoding],[output_encoding])//data是要进行加密的数据，可以是Buffer或String对象//input_encoding是输入数据的编码格式//output_encoding是输出数据的编码格式 使用加密对象的final( )方法返回最终加密后的数据：12cipher.final([encoding])//encoding为输出的加密数据编码格式，如hex、binary、base64等 对称加密实例下面是一个完整使用密钥进行数据加密的示例：12345678const crypto=require('crypto');var key='my-secret-key';var cipher=crypto.createCipher('des',key);var result=cipher.update('一些需要加密的非常重要的数据','utf8','hex');result+=cipher.final('hex');console.log(result); *cipher对称加密和消息摘要算法的不同点在于cipher对称加密每次追加加密数据都会返回一段输出的加密数据，所以result输出结果需要拼接，追加数据越多，拼接结果越长。12345678910111213const crypto=require('crypto');const fs=require('fs');var secret='my-secret-123';var input=fs.createReadStream('4.js');var cipher=crypto.createCipher('des',secret);var result=null;input.on('data',(data)=&gt;&#123; result+=cipher.update(data,'UTF-8','hex');&#125;)input.on('end',()=&gt;&#123; result+=cipher.final('hex'); console.log(result);&#125;) 对称解密要进行数据解密，必须创建Decipher类对象：123var decipher=crypto.createDecipher(algorithm,key);//algorithm为要使用的解密算法，如blowfish、des、seed等//key为解密密钥 使用解密对象的update( )方法追加指定要加密的数据：12decipher.update(data,[input_encoding],[output_encoding])//data是要进行解密的数据，可以是Buffer或者String对象 使用解密对象的final( )方法返回最终解密后的数据：12decipher.final([encoding]);//encoding为要输出的解密数据的编码格式，如utf8、ascii、binary等 对称解密示例下面是一个完整使用密钥加密后数据进行数据解密的示例：12345678const crypto=require('crypto');var secret='my-secret-123';var data='7afc52f67d7b59a611a590aa4067765d430086d567ce0495ff32a706c91781792262ee625f826132'var decipher=crypto.createDecipher('des',secret);var result=decipher.update(data,'hex','UTF-8');result+=decipher.final('UTF-8');console.log(result);//输出：一段需要加密的数据ABC123 数组签名（非对称加密）数字签名：私钥所有者在将数据发送之前，使用私钥进行加密，称为签名；数据接收者受到加密后的数据，使用公钥对数据进行验证，以确保数据在传输过程中未被篡改。 进行签名之前，数据所有者必须创建出自己的私钥及对应公钥： 创建私钥:1$ openssl genrsa -out d:/privatekey.pem 1024 生成公钥:1$ openssl req -key d:/privatekey.pem -new -x509 -out publickey.pem openssl工具xampp软件已经集成，打开xampp目录的xampp/apache/bin目录，按住shift右击鼠标，选择在此处打开命令行窗口1$ C:\xampp\apache\bin&gt; 现在我们使用openssl命令，提示‘openssl’不是内部命令，这是因为openssl程序现在缺少一个openssl.cnf配置文件。这个文件保存在apache的conf目录下，自需要配置一下即可。1$ C:\xampp\apache\bin\set OPENSSL_CONF=../conf/openssl.cnf 现在配置完毕，可以使用openssl工具了。 要进行数组签名，必须创建Sign类的对象：12var sign=crypto.createSign(algorithm);//algorithm为主要使用的签名算法，如RSA-SHA256等 使用签名对象的update( )方法追加指定签名的数据：12sign.update(data);//data是要进行签名的数据，可以是Buffer或String对象 使用签名对象的sign( )方法返回最终签名后的数据：123sign.sign(private_key,[encoding])//private_key为签名所用到的私钥//encoding为输出的签名数据编码格式，如hex、binary、base64等 数字签名示例下面是一个完整使用私钥进行数据签名的示例：12345678const crypto=require('crypto');const fs=require('fs');var data='需要进行数据签名的数据';var sign=crypto.createSign('RSA-SHA256');var privatekey=fs.readFileSync('privatekey.pem');sign.update(data);var result=sign.sign(privatekey,'hex');console.log(result) 签名验证（非对称解密）要进行签名的验证，必须创建Verify类的对象：12var verify=crypto.createVerify(algorithm);//algorithm为要使用的签名验证算法，如RSA-SHA256等 使用签名验证对象的update( )方法追加指定要验证的数据：12verif.update(data);//data是进行签名验证的原始数据，可以是Buffer或者String对象 使用签名验证对象的verify( )方法对签名后的数据进行验证：1234verify.verify(publick_key,sign_result,[encoding]);//publick_key为签名验证所得到的的公钥//sign_result为签名后的数据//encoding为签名数据的编码格式，如hex、binary、base64等 签名验证示例下面是一个完整的使用公钥进行数据签名验证的示例：1234567891011const crypto=require('crypto');const fs=require('fs');var data='需要进行数据签名的数据';var signresult='5d1cc4f169081ea39cf6173f5b36284eb8303af1e46b36c87386e60390c3738cbd82be6f4a9937dc66b5698022cc5bb0272a4dd8d0c565250d0360b988fd1640bac98564cc012755c9e412c7554303ab03ce761a8c57168708064b9022e6a88214d011e60732698dbce0b5e07f607dcf7410bb1ec0940c95a4c914fa91abb5c4'var publickey=fs.readFileSync('publickkey.pem');var verify=crypto.createVerify('RSA-SHA256');verify.update(data);var result=verify.verify(publickey,signresult,'hex');console.log(result)//返回布尔值]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>Nodejs</tag>
        <tag>ES6</tag>
        <tag>数据加密</tag>
        <tag>数据解密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件IO]]></title>
    <url>%2F2017%2F07%2F31%2F%E6%96%87%E4%BB%B6IO%2F</url>
    <content type="text"><![CDATA[读写文件全部内容对于数据量不是很大的文件，可以一次性的写入其中的全部内容。 方法名 说明 fs.readFile(file[,options],callback) 读取文件内容 fs.writeFile(file,data[,options],callback) 读出内容 fs.appendFile(file,data[,options],callback) 追加内容 读取文件全部内容1234567const fs=require("fs");const src="./htdocs/index.html";fs.readFile(src,(err,data)=&gt;&#123; if(err)throw err; console.log(data); //读取到的数据保存在一个Buffer实例中 console.log(data.toString());&#125;) 向文件中写出内容1234567const fs=require("fs");const dest="./htdocs/index.html";var data='Som Data';fs.writeFile(dest,data,(err)=&gt;&#123; if(err)throw err; console.log('Write Finished!');&#125;) 注意：若目标文件不存在，则writeFile方法会自动创建该文件；若目标文件存在，该方法会覆盖原来所以内容。 读写文件部分内容读写文件的部分内容，需要按照如下步骤进行： 1、 打开指定文件，获取对应的”文件描述符（File Descriptor）”;2、 读取或写出文件指定部分的内容；3、 关闭文件带其它进程使用。 方法名 说明 fs.open(path,flags[,mode],callback) 打开文件 fs.read(fd,buffer,offset,length,position,callback) 读取文件 fs.write(fd,buffer,offset,length[,position],callback) 写出文件 fs.close(fd.callback) 关闭文件 读取文件部分内容1234567891011const fs=require("fs");const src='./log/full.txt';fs.open(src,'r',(err,fd)=&gt;&#123; if(err)throw err; const buf=new Buffer(1024); fs.read(fd,buf,0,1024,0,(err,bytesRead,buffer)=&gt;&#123; if(err)throw err; console.log(buffer.toString('UTF-8',0,bytesRead)); fs.close(fd); &#125;)&#125;) 向文件写出部分内容1234567891011const fs=require("fs");const dest='./log/part.txt';fs.open(dest,'w',(err,fd)=&gt;&#123; if(err)throw err; const buf=new Buffer("Some Content..."); fs.write(fd,buf,0,'UTF-8',(err,bytesWriten,string)=&gt;&#123; if(err)throw err; console.log('Write Finish!'); fs.close(fd); &#125;)&#125;) 文件流的流式操作流(Stream)，是一组有序的，有起点和终点的字节或字符数据的集合。 Node.js中，stream模块的readable接口的实现对象都可以用来读取文件中的部分数据暂存在缓冲区中，如:fs.readStream、http.IncomingMessage、net.Socket/process.stdin等；这些对象都继承了EventEmitter类，在读取数据过程中，可以触发各种流读取相关事件。 Stream模块中的Writable接口的实现对象都可以用来写出数据到缓冲区中、待缓冲区满后再向物理介质输出:fs.writeStream、http.ClientRequest、http.serverResponse、net.Scoket、process.stdout等；这些对象都继承了EventEmitter类，在写出数据过程中，可以触发各种数据写出相关事件。 输入流对象事件stream.Readable对象可以触发下列事件: 事件名 说明 readable 当可以从流中读取数据时触发 data 当读取到数据时触发 end 当读取到流结尾时触发 error 当出现读取错误时触发 close 当流关闭触发 输入流对象方法stream.Readable对象可以执行如下操作: 事件名 说明 read（） 读取数据 setEncoding() 设置字符编码 pause() 暂停读取 resume() 继续读取 pipe() 设置一个数据通道 unpipe() 取消设置的数据通道 输出流对象事件stream.Writable对象可以触发下列事件: 事件名 说明 drain 当输出缓冲区已经排空时触发 finish 当end()方法把所有数据写出到缓存区时触发 pipe 当用于读取数据的对象调用pipe()时触发 unpipe 当用于读取数据的对象调用unpipe()时触发 error 当输出过程产生错误时触发 输出流对象方法 方法名 说明 write() 写出数据 end() 当没有更多数据需要再被输出时调用，此方法将情况输出缓存区 1234567891011121314const fs=require('fs');var reader=fs.createReadStream('./htdocs/2.mp4');var writer=fs.createWriteStream('./log/10.mp4');reader.on('data',function (buf) &#123; writer.write(buf,0,buf.length);&#125;);reader.on('end',function (err) &#123; if(err)throw err; reader.close(); writer.end();&#125;);writer.on('finish',function () &#123; console.log('输出文件完成')&#125;) 使用管道Pipe:管道，可以用于自动的读取一个Readable对象中的所以数据，并写出到指定的Writable对象中。 123456789const fs=require('fs');const src='./htdocs/index.html';const dest='./backup/index.html';var reader=fs.createReadStream(src);var writer=fs.createWriteSteam(dest);reader.pipe(writer); //使用管道实现自动读写reader.on('end',()=&gt;&#123; console.log('Copy Finish!');&#125;)]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>Nodejs</tag>
        <tag>文件读取</tag>
        <tag>文件IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fs模块]]></title>
    <url>%2F2017%2F07%2F31%2Ffs%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[fs模块是Node.js核心模块之一，提供了符合POSIX规范的操作文件和目录的基本方法。这些方法都有同步和异步两种形式。在I/O操作密集型的应用中，推荐使用异步调用方式，以避免整个应用程序的阻塞。所有异步的回调函数中第一个参数都是一个IO错误对象： 12345678910111213/*********同步调用方式***************/const fs=require('fs');fs.unlinkSync('/f2');console.log('succ');//文件删除完成才输出succ/*********异步调用方式**************/const fs=require('fs');fs.unlunk('/f',(err)=&gt;&#123; if(err)throw err; console.log('succ');//文件没有删除完成就会输出succ&#125;) 常用Class Class名 说明 fs.stats 文件或目录的统计信息描述对象 fs.readStream stream.Readable接口的实现对象 fs.writeStream stream.Writable接口的实现对象 fs.FSWatcher 可用于监视文件修改的文件监视器对象 常用方法 方法名 说明 fs.mkdir() 创建目录 fs.rmdir() 删除目录 fs.readFile() 读取文件内容 fs.writeFile() 向文件中写出内容 fs.appendFile() 向文件中追加内容 fs.unlink() 删除文件 fs.rename() 重命名文件 1234567891011121314151617const fs=require('fs');var data=fs.readFileSync('./htdocs/index.html');console.log(data.toString());console.log('脚本执行结束');fs.readFile('./htdocs/index.html',function (err, data) &#123; if(err)throw err; console.log(data); console.log(data.toString()); fs.writeFile('./htdocs/index_backup.html',data,function (err) &#123; if(err)throw err; console.log('备份完成') &#125;) fs.appendFile('./htdocs/index_backup.html',data,function (err) &#123; if(err)throw err; console.log('追加完成') &#125;)&#125;); 文件信息统计fs.stat()和fs.statSync()方法用于返回一个文件或目录的统计信息对象（fs.Stats类型）。 1234567891011&#123; mode:33188, nlink:1, uid:100, gid:100, size:527, atime:Mon,10,Oct 2011 23:24:11 GMT, mtime:Mone,10 Oct 2011 23:24:11 GMT, ctime:Mon,10 Oct 2011 23:24:11 GMT, birthtime:Mon,10 Oct 2011 23:24:11 GMT&#125; fs.Stats对象还提供了如下方法可用于检测文件的物理特性： 方法名 说明 stats.isFile() 是否为文件 stats.isDirectory() 是否为目录 stats.isBlockDevice() 是否为块设备，如磁盘 stats.isCharacterDevice() 是否为字符设备，如键盘 stats.isFIFO() 是否为FIFO设备，如打印机 stats.isSocket() 是否为Socket文件 文件模式类Unix文件系统中，针对文件和目录的操作，为了控制不同用户不同权限，定义了如下的操作权限： r: Read,读取权限，对应数字为4 w: Write,写出权限，对应数字为2 x: Execute，执行权限，对应数字为1 不同的用户又分为如下三种类型: u: User,文件所有者 g: Group,文件所有者所在组的其他用户 o: Other，其他用户 1234-rwx------ 700 文件所有者对文件具有读取、写入和执行的权限。-rwxr--r-- 744 文件所有者具有读、写与执行的权限。其他用户则具有读取的权限。-rw-rw-r-- 664 文件所有者与同组用户对文件具有读写的权限，而其他用户具有读取的权限。drwx--x--x 711 目录所有者具有读写与进入目录的权限，其他用户只能进入该目录。 操作目录 方法名 说明 fs.mkdir(path[,],callback) 创建指定目录 fs.mkdirSync(path[,mode]) 创建指定目录 fs.rmdir(path,callback) 删除指定目录 fs.rmdirSync(path) 删除指定目录 fs.readdir(path[,options],callback) 读取目录下内容 fs.readdirSync(path[,options]) 读取目录下内容 1234567891011const fs=require('fs');const path='./htdocs';fs.stat(path,(err,stats)=&gt;&#123; if(err)&#123;//指定目录不存在 fs.mkdir(path); &#125;else&#123;//指定路径存在 fs.readdir(path,()=&gt;&#123; console.log(list); &#125;) &#125;&#125;); 123456789101112131415161718192021const fs=require('fs'); fs.mkdir('./htdocs/img',777,function (err) &#123; if(err)&#123; throw err &#125;; console.log("目录创建完成");&#125;)fs.readdir('./htdocs',function (err,stats) &#123; if(err)&#123; throw err; &#125;else&#123; console.log(stats) &#125;&#125;);fs.rmdir('./htdocs/img',function (err) &#123; if(err)&#123; throw err; &#125;else&#123; console.log('文件删除成功'); &#125;&#125;)]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>Nodejs</tag>
        <tag>fs模块</tag>
        <tag>文件读取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Buffer数据缓冲区]]></title>
    <url>%2F2017%2F07%2F21%2FBuffer%E6%95%B0%E6%8D%AE%E7%BC%93%E5%86%B2%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[Global.BufferBuffer：缓冲区，指一块用于短暂数据的内存区域（在V8引擎的堆内存之外），其中储存着一定数量的字节或者字符数据。与String类型相对的，Buffer对象特别适用于存储二进制数据Buffer类型的实例类似于一个整数数组，其每个元素是一个字节的十六进制整数；一旦创建，就无法从新改变大小。与String不同的是，Buffer中的任意部分内容都是可以修改的。Buffer class是全局对象global的成员，故使用该模块无需使用require(‘buffer’)进行引入。 创建Buffer实例Buffer对象的实例，可以通过读取文件获得，也可以直接构造： 1234567891011//创建一个长度为10字节的缓冲区const buf1=new Buffer(10);//创建一个长度为3字节的缓冲区，内容为0X01,0x0a,0xffconst buf2=new Buffer([1,10,255]);//创建一个长度为4字节的缓冲区，内容为0x61,0x62,0x41,0x42const buf3=new Buffer('abAB');//创建一个长度为6字节的缓冲区，内容为0xe4,0xb8,0x80,0xe4,0xba,0x8cconst buf4=new Buffer('一二','utf8'); Buffer和String的转换123456789101112//将String内容转换为Buffer对象new Buffer(str);buf.wirte(str,offset);//将Buffer内容转换为特定编码的Stringconsole.log(buf.toString()); //默认采用UTF-8编码console.log(buf.toString('binary'));console.log(buf.toString('hex'));console.log(buf.toString('ascii'));console.log(buf.toString('utf8'));console.log(buf.toString('utf16le'));console.log(buf.toString('base64')); 遍历Buffer可以使用for循环配合buf.length和buf[index]来遍历缓冲区中的每个数据，也可以使用ES6新特性的for…of()循环来遍历每个数据值。12345678910//创建一个长度为8字节的缓冲区const buf=new Buffer('ab一二');for(var i=0;i&lt;buf.length;i++)&#123; //使用for循环遍历缓冲区 console.log('%d-%s',buf[i],buf[i].toString(16));&#125;for(var v of buf)&#123; //使用for...of循环遍历缓冲区 console.log('%d-%s',v,v.toString(16));&#125; Buffer常用操作 成员 说明 buf.compare() 比较两个缓冲区的大小 buf.copy() 拷贝缓冲区的（部分）内容 buf.equals() 判定两个缓冲区的内容是否完全相同 buf.fill() 使用指定的值填充缓冲区 buf.indexOf() 指定值在缓冲区中的开始下标 buf.includes() 判定是否包含指定值 buf.slice() 返回同一缓冲区中的部分值 buf.toJSON() 转为JSON字符串格式 buf.write() 向缓冲区指定位置写出指定值 12345678var src=new Buffer('ABCD');console.log(src); //&lt;Buffer 41 42 43 44&gt;var sub=src.slice(2);console.log(sub); //&lt;Buffer 43 44&gt;sub[0]=0x44;console.log(sub); //&lt;Buffer 44 44&gt;console.log(src.toJSON()) //&#123; type: 'Buffer', data: [ 65, 66, 68, 68 ] &#125;]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>Nodejs</tag>
        <tag>Buffer数据缓冲区</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs事件驱动的异步模型+事件和event模块]]></title>
    <url>%2F2017%2F07%2F21%2FNodejs%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[进程进程：process/Task,是程序的动态执行。操作系统将可执行文件从磁盘调入内存，为其分配必要的可执行代码内存和数据内存空间，这一过程就是创建了一个进程—进程是操作系统分配内存的基本单位。 线程线程:Thread，是进程内部执行代码的基本单位。一个进程可以同时创建多个线程，并发的执行多段代码。每个线程需要自己独立的数据内存空间，大小为2MB；所以一台8GB内存的计算机，理论上可以同时存在4000个线程。 进程与线程的关系 ① 进程是操作系统创建任务分配内存的基本单位；② 线程是进程内部执行代码的基本单位；③ 线程处于进程内部；④ 一个进程内部必须至少存在一个线程；⑤ 一个进程内部也可以同时存在多个线程，这些线程间并发执行。 单线程服务器早期”单线程服务器”中，服务器端只有一个线程，依次为每个客户端请求提供服务，某一时刻只能为一个客户端提供相应。特点： 程序设计简单；运行效率太低； 多线程服务器为了同时处理多个客户端的请求，很多服务器应用都设计为多线程运行模式，即每接收到一个客户端连接请求，都会有创建一个专门的服务线程。 多线程模型的特点多线程模型作为当前广泛采用的服务器运行模型，被大量的服务器程序所采用（如Apache Httpd）。对于CPU密集型请求，可以充分利用多核CPU的优势，同时为尽可能多的客户端提供服务。但是，多线程模型也存在下列问题： （1） 每个线程内部的操作都是线性执行，耗时操作会阻塞后续操作；（2） 受限于线程总数的现在，无法并发的处理大量的请求；（3） 过多频繁的线程上下文切换，产生了更多的CPU开销；（4） 多线程并发往往伴随互斥和死锁等问题，增加了程序设计复杂度。 综上，多线程模型在高并发的I/O密集型应用中没有太多的优势。 Node.js中的单线程服务器为了解决多线服务器在高并发的I/O密集型应用中的不足，同时避免早期简单单线程服务器的性能障碍，Node.js采用了一种基于”事件循环”的非阻塞式单线程模型，实现了如下两个目标：保证每个请求都可以快速得到响应；实现远超多线程模型的并发连接数。提示 : Node.js在JS层面是单线程的—没有创建新线程的机制。但在C/C++底层是多线程的，即访问底层操作系统服务时，存在多个并发工作线程的情形—使用了线程池。 阻塞执行阻塞（Block）：也成为同步执行（Synchronize），只有前面的操作全部执行完成，才能开始后续的操作。 123var conn=mysql.createConnection(...); //步骤1var result=conn.query('INSERT...'); //步骤2conn.end(); 非阻塞执行非阻塞（Non-Block）：也称为异步执行（Asynchronize），后面的操作不必等待之前的操作的执行完毕，可以先执行。 12345console.log("读取请求数据"); //操作1fs.writeFile('app.log','访问日志',()=&gt;&#123; console.log("写出操作日志完成"); //操作2&#125;)console.log("输出响应数据"); //操作3 非阻塞执行的异步回调Node.js中的业务性代码，都是在单一的主线程中执行的；当遇到耗时的阻塞操作时（如：文件IO、网络访问、数据库请求等），不会等待其执行完毕，而是注册一个处理执行结果的回调函数，继续执行后续的代码。待耗时的阻塞操作执行完成时，其对应的回调函数会转入回调函数队列，主线程在下次事件循环时会执行这些回调 1234567//同步函数调用var data=fs.readFileSync('app.log');console.log('文件内容：'+data);//异步函数回调fs.readFile('app.log',function (err, data) &#123; console.log("文件内容："+data);&#125;) 事件驱动 事件驱动编程12345678910111213var conn=openConnection();var data=conn.readData();response.writeData(data);request.on('getData',function()&#123; var conn=openConnection(); conn.on('open',function()&#123; var data=readData(); data.on(''complete',function()&#123; response.sendData() return; &#125;) &#125;)&#125;) 添加事件回调Node.js中添加新的事件回调函数到事件队列，可以使用下述五种方法之一： （1） 原生模块与定义的事件和监听器；（2） 异步I/O库；（3） 定时器回调；（4） 全局对象process.netxTick()函数；（将回调放在本次事件循环队列末尾，下次循环开头，他要比所有的回调都要更早执行）（5） 自定义事件。 原生模块预定义事件 123456socket.on('close',()=&gt;&#123; console.log('connection closed'); var index=socket.indexOf(socket); //服务器断开相应连接 socket.splice(index,1);&#125;) 异步IO库 12345678var mysql=require('mysql');var pool=mysql.createPool(config);pool.getConnection((err,connection)=&gt;&#123; connection.query('SELECT something FROM sometable',(err,rows)=&gt;&#123; //处理数据 connection.end(); &#125;);&#125;) 使用定时器添加回调函数 123456var timer=setInterval(()=&gt;&#123; //周期性任务 if(退出条件)&#123; clearInterval(timer); &#125;&#125;,1000) 123var timer=setTimeout(()=&gt;&#123; //一次性任务&#125;,1000) process.nextTick() 12345console.log('start');process.next(()=&gt;&#123; console.log('nextTick callback');&#125;)console.log('scheduled'); events模块Node.js原生模块之一的event模块，提供了EventEmitter类型，Node.js中所有可用触发事件的对象都最终继承自这个对象。 方法 说明 addListener(event,listener) 为指定事件绑定监听函数 on(event,listener) 为指定事件绑定监听函数 once(event,listener) 为事件绑定只能执行一次的监听函数 removeListener(event,listener) 删除指定事件的监听函数 removeAllListeners(event) 删除指定函数所有的监听函数 setMaxListeners(n) 设定事件处理函数的最大数量 listeners(event) 获取指定事件所有的监听函数 emit(event,[arg1],[arg2],…) 手工触发指定事件 自定义事件自定义事件 123456const EventEmitter=require('events');var emitter=new EventEmitter();emitter.on('some_event',function()&#123; //绑定事件回调 //操作&#125;)emitter.emit('some_event'); //触发事件 继承EventEmitter12345678910111213"use strict"const EventEmitter=require('events');class DBConnection extends EventEmitter&#123; connect()&#123; // this.emit('connected'); //触发事件 &#125;&#125;var conn=new DBConnection();conn.on('connected',()=&gt;&#123; //绑定监听函数 console.log('Connect Sucessfuly!');&#125;);conn.connect(); 事件传参1234567const myEmitter=new MyEmitter();myEmitter.on('myevent',function(a,b)&#123; console.log(a,b,this); //若此处使用了箭头函数，则this不再指向myEmitter &#125;&#125;);myEmitter.emit('myevent',10,20); 错误事件12345const myEmitter=new MyEmitter();myEmitter.on('error',(err)=&gt;&#123; console.log('An Error Occured!');&#125;);myEmitter.emit('err',new Error('ERR MSG!');) 一次性事件1234567const myEmitter=new MyEmitter();var m=0;myEmitter.once('myevent',()=&gt;&#123; console.log(++m);&#125;);myEmitter.emit('myevent'); //输出：1myEmitter.emit('myevent'); //没有任何输出 监听器数量由于可能引起内存泄露，Node.js默认情况下对一个对象的某个事件最多运行设置10个监听函数，超过限制了只能使用setMaxListeners函数进行修改。 1234//取消监听函数数量限制myEmitter.setMaxListeners(0);//返回指定对象上指定事件的监听函数数量EventListener.listenerCount(myEmitter,'myevent');]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>Nodejs</tag>
        <tag>Nodejs事件驱动的异步模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yeoman工作流工具]]></title>
    <url>%2F2017%2F07%2F20%2FYeoman%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Yeoman介绍Yeoman是一个通用的项目基础框架搭建工具，通过其提供的众多“生产器（Generator）”，并整合业内众多最好的开发工具，帮助开发者快速的创建整个项目或项目中的部分内容，并将项目的维护工作实现标准化流水线化。 Yeoman可以使用在如下场景中： （1） 快速搭建一个标准化的全新项目；（2） 创建项目中的一部分，如带单元测试的控制器（3） 创建标准化的模块或者包；（4） 强制施行特定的开发标准或者最佳实践；（5） 为推广而创建的示例项目等等。 Yeoman三大组成部分为定义标准化的工作流程，Yeoman提供并整合了三大工具： （1）项目脚手架：yo（2）项目自动化构建工具：gulp或grunt（3）包管理工具：npm或bower Yeoman使用步骤由于Yeoman依赖了众多的工具软件，所以使用过程稍显麻烦： （1） 安装Git客户端工具——bower下载依赖时需要使用；（2） 安装最新版本的Node.js和NPM——下载yo/gulp等工具；（3） 安装全局Bower工具；（4） 安装全局Gulp工具；（5） 安装全局Yeoman工具：yo;1npm install yo -g （6） 使用yo工具下载generator；（7） 使用Yeoman生成器创建项目；（8） 启动内置的服务器任务，在客户端访问项目。 Yeoman创建WebApp应用使用Yeoman的generator-webapp创建一个最简单的webapp。可以进入yo后，使用键盘上下选择：1$ install a generator 输入webapp，在搜索建议中选择Webapp： 下载完成后，在选项列表运行Webapp生成器即可。由Yeoman创建好的Webapp项目已经包含了完整的项目目录结构，可以运行其中的gulpfile.js中定义的server:dist任务即可发布项目并在默认浏览器浏览；server:test任务即可进行自动化测试。 Yeoman创建WebApp应用使用Yeoman的generator-bootstrap创建一个Bootstrap Version3或4的相关应用。可以进入yo后，使用键盘上下键选择：1$ install a generator 输入bootstrap，在搜索建议中选择bootstrap；下载完成后，在选择列表选择Bootstrap生成器即可。 Yeoman创建AngularJS应用使用Yeoman的generator-angular创建一个Angular应用。可以进入yo后，使用键盘上下键选择：1$ install a generator 输入angular，在搜索建议选择angular；下载完成后，在选项列表中选择运行Angular生成器即可。]]></content>
      <categories>
        <category>Web应用开发工具</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>Nodejs</tag>
        <tag>Web前端工作流工具</tag>
        <tag>Yeoman</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gulp项目自动化构建工具]]></title>
    <url>%2F2017%2F07%2F20%2FGulp%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Gulp介绍Gulp是基于Node.js的自动化项目构建工具，他能自动化地完成html、javascript、coffee、css、less、sass、image等文件的测试、合并、压缩、编译转换、浏览器自动刷新等任务，并监视文件的改的，然后再次自动执行上述任务；只要在gulpfile.js中正确配置好了任务，任务运行器就会自动帮你完成大部分重复的无聊的项目构建工作。 使用步骤Gulp的使用遵循以下步骤即可：（1）在全局下载gulp，可以再命令行中执行gulp工具；1$ npm i gulp -g （2）在项目中添加gulp模块，可以在代码中引入gulp；12$ npm init$ npm i gulp --save-dev （3）创建gulpfile.js，声明要执行的Gulp任务；（4）命令行调用gulp工具，执行指定的任务。12$ gulp taskName //执行指定名称的任务$ gulp //执行名为default的任务 Gulp对象方法使用Gulp进行项目的自动化构建，必须创建gulpfile.js文件。此文件中引入gulp模块，然后开始声明要执行的各种项目结构任务。gulp模块对象的使用非常简单，仅四个成员方法： 方法 说明 gulp.task(name,[,deps],fn) 声明一个新的Gulp任务 gulp.src(globs)[,options] 指定需要处理的源文件的路径，gulp借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，gulp.src返回当前文件流致可以插件； gulp.dest(path[,options]) 指定处理完后文件输出的路径； gulp.watch(glob[,opts],task) or gulp.watch(glob[,opts,cb]) 用于监听文件变化，文件一修改就会执行指定的任务； 下面是一个简单的gulpfile.js示例，它仅定义了一个默认任务：123456const gulp =require(‘gulp’);gulp.task(‘default’,function()&#123;console.log(‘gulp default task’);&#125;)//default默认的任务 要执行此任务，只需要在命令行中执行：123$ gulp default//或者$ gulp *Webstorm这款前端IDE对Gulp支持非常好，在Webstrom中只需要将鼠标放在Gulp代码方法的任务名上右击选择，Run任务名 即可执行该Gulp任务。 定义多个相互依赖的任务下面是gulpfile定义了多个相互依赖的任务： 12345678910const gulp=require(‘gulp’);gulp.task(‘task1’,function()&#123; console.log(‘task1 executed...’);&#125;)gulp.task(‘task2’,function()&#123; console.log(‘task2 executed...’);&#125;)gulp.task(‘defult’,[‘task1’,’task2’]);//默认任务依赖task1和task2,就是说只有defalut被调用那么依赖任务也会被调用 Gulp插件Gulp自身只有四个方法，实际功能是由更多的“插件”来完成，例如： gulp-less：实现了Less文件到CSS文件的编译 gulp-uglify：压缩JS文件，减小文件大小 gulp-concat：合并JavaScript文件，减少文件大小 gulp-clean-css：压缩css文件，减小文件大小 gulp-htmlmin：压缩html，可以压缩页面JavaScript、css去除空格、注释、删除多余属性等操作 gulp-imagemin:压缩图片文件（包括PNG、JPEG、GIF和SVG）等 上述插件包都需要独立的安装，如:1$ npm i gulp-less --save-dev 使用gulp-less插件Gulp-less插件用于将指定目录下的所有.less文件编译为同名的.css文件，可以指定监视特定目录下的所有.less文件，如下：12345678910111213const gulp=require('gulp');const less=require('gulp-less');gulp.task('less-task',function () &#123; gulp.src('src/less/*.less') .pipe(less()) .pipe(gulp.dest('dist/css'))// gulp.src返回输入流对象所，以可以使用管道pipe把输入流传递给less()工具，// less()再把返回的输入流交给gulp目标对象gulp.dest('输出的目录')&#125;);gulp.task('watch',function () &#123; gulp.watch('src/less/*.less',['less-task'])&#125;);gulp.task('default',['less-task','watch']); 使用gulp-uglify插件gulp-uglify用于压缩.js文件，减小文件大小。12345678910111213const gulp=require('gulp');const uglify=require('gulp-uglify');gulp.task('uglify-task',function () &#123; //压缩src/js目录下的所有的js文件 //除了test1.js和test2.js（**匹配src/js的0个或多个子文件夹） gulp.src(['src/js/*.js','!src/js/**/&#123;test1,test2&#125;.js']) .pipe(uglify()) .pipe(gulp.dest('dist/js'))&#125;)gulp.task('watch',function () &#123; gulp.watch('src/js/*.js',['uglify-task'])&#125;)gulp.task('default',['uglify-task','watch']); 使用gulp-concat插件gulp-concat插件用于合并js文件，减少网络请求。12345678910111213const gulp=require('gulp');const concat=require('gulp-concat');const uglify=require('gulp-uglify');gulp.task('concat',function () &#123; gulp.src('src/js/*.js') .pipe(concat('all.js'))//合并后的文件名 .pipe(uglify()) .pipe(gulp.dest('dist/js'))&#125;);gulp.task('watch',function () &#123; gulp.watch('src/js/*.js',['concat']);&#125;)gulp.task('default',['concat','watch']); 使用gulp-clean-css插件使用gulp-clean-css压缩.css文件，减小文件大小。1234567891011const gulp=require('gulp');const css=require('gulp-clean-css');gulp.task('css',function () &#123; gulp.src('src/css/*.css') .pipe(css()) .pipe(gulp.dest('dist/css'))&#125;);gulp.task('watch',function () &#123; gulp.watch('src/css/*.css',['css']);&#125;);gulp.task('default',['css','watch']); 使用gulp-htmlmin插件使用gulp-htmlmin压缩html，可以压缩页面JavaScript、css,去除页面空格、注释，删除多余属性等操作。123456789101112131415161718const gulp=require('gulp');const htmlmin=require('gulp-htmlmin');gulp.task('htmlmin',function () &#123; var options=&#123; collapseBooleanAttributes:true,//是否折叠布尔属性 collapseWhitespace:true,//是否折叠空白字符 minifyCSS:true,//精简CSS minifyJS:true,//精简JS removeComments:true//是否删除HTML注释 &#125; gulp.src('src/*.html') .pipe(htmlmin(options)) .pipe(gulp.dest('dist'))&#125;);gulp.task('watch',function () &#123; gulp.watch('src/*.html',[htmlmin])&#125;);gulp.task('default',['htmlmin','watch']); Gulp综合案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const gulp=require('gulp');const css=require('gulp-clean-css');const uglify=require('gulp-uglify');const htmlMin=require('gulp-htmlmin');const imagemin=require('gulp-imagemin');const spriter=require('gulp-css-spriter');const babel=require('gulp-babel');//压缩css,以及拼合css使用的背景图为雪碧图gulp.task('css',function () &#123; gulp.src('style/*.css') .pipe(spriter(&#123; //合成的雪碧图存放位置和名字 'spriteSheet':'./dist/images/spritesheet.png', //css中使用雪碧图的路径 'pathToSpriteSheetFromCSS': '../images/spritesheet.png' &#125;)) .pipe(css()) .pipe(gulp.dest('dist/style'));&#125;);//将js文件中ES6的语法转换为ES5并且压缩jsgulp.task('js',function () &#123; gulp.src('script/*.js') .pipe(babel(&#123;presets: ['es2015']&#125;)) .pipe(uglify()) .pipe(gulp.dest('dist/script'));&#125;);//压缩htmlgulp.task('htmlmin',function () &#123; var options=&#123; collapseBooleanAttributes:true,//是否折叠布尔属性 collapseWhitespace:true,//是否折叠空白字符 minifyCSS:true,//精简CSS minifyJS:true,//精简JS removeComments:true//是否删除HTML注释 &#125; gulp.src('templates/*.html') .pipe(htmlMin(options)) .pipe(gulp.dest('dist/templates'))&#125;);//压缩图片gulp.task('img',function () &#123; gulp.src('images/*.&#123;png,jpg,gif,ico&#125;') .pipe(imagemin()) .pipe(gulp.dest('dist/images'));&#125;);//监视文件gulp.task('watch',function () &#123; gulp.watch('style/*.css',['css']) gulp.watch('script/*.js',['js']); gulp.watch('templates/*.html',['htmlmin']); gulp.watch('images/*.&#123;png,jpg,gif,ico&#125;',['img']);&#125;)gulp.task('default',['css','js','htmlmin','img','watch']);]]></content>
      <categories>
        <category>Web应用开发工具</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>Nodejs</tag>
        <tag>Web前端自动化构建工具</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bower前端依赖包管理工具]]></title>
    <url>%2F2017%2F07%2F20%2FBower%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Bower介绍Bower是一个前端项目的软件包管理器，她可用于搜索、安装、卸载前端项目所依赖的HTML/CSS/JS框架、类库资源包。Bower的作用于NPM有些类似，区别在于Bower更偏重于管理客户端依赖的资源包，如jQuery、Bootsrap等、而NPM更偏重管理服务器端Node.js所依赖的资源包，如Express、Socket.IO等等。 *现在有一个趋势是NPM也可以管理前端所以依赖的资源包，但是根据软件基金会的原则，一个软件只做好一个功能就行，NPM还是更偏向于后端服务器包管理。 我们打开Bower官网会看到提示 …psst! While Bower is maintained, we recommend yarn and webpack for new front-end projects!提示Bower现在处于实验状态，推荐使用yarn和webpack这两个工具。但是在以前非常流行，并且现在很多前端自动化构建工具底层都使用到了Bower,所以很有学习的必要。 安装步骤使用Bower需要按照以下步骤进行： （1）安装Git客户端工具——Bower下载依赖包时需要使用。 官网：https://git-scm.com/（2）安装新版本的Node.js和NPM 官网：https://node.js.org/en/（3）安装全局Bower工具;1npm i bower -g （4）开始使用Bower工具管理项目依赖的包。 Bower常用命令全局Bower工具安装完毕后，可以使用bower help命令列出所有可用的bower命令，如下所示： 指定包的安装目录.bowerrc文件是自定义bower下载的代码包的保存目录。在项目的根目录下创建文件，其内容是一个JSON字符串，如下所示：123&#123; "directory":"bower_components"&#125; Bower初始化命令行进入项目目录中，输入命令如下：1$ Bower init 会提示你输入一些基本信息，根据提示按回车或空格即可，然后会生产一个bower.json文件，用来保存该项目的配置，如下： 1234567&#123; "name":"myproject", "dependencies":&#123; &#125;, "devDependencies":&#123; &#125;&#125; 包的安装接下来开始使用Bower下载并安装项目需要的包了，例如：1$ bower install jquery --save Bower就会从远程下载jquery最新版本到指定目录下。观察bower.json文件已被文件添加如下内容：123"dependencies":&#123; "jquery":"~3.2.1"&#125; 包的维护查看当前项目依赖的包，可以使用：1$ bower list 查看指定包的相关信息，以及可用的其他版本，可以使用：1$ bower info jquery 想要更新已经安装的包，如安装其他版本，可用使用1$ bower update 查看包含指定关键字的包有哪些：1$ bower search jquery 卸载已经安装的包：1$ bower uninstall jquery 包的使用Bower包的使用方式有两种： (1)直接在HTML中使用script标记引用；1&lt;script src=”bower_components/jquery/dist/jquery.min.js”&gt;&lt;/script&gt; (2)推荐将Bower整合到其他工具如Grunt、RequireJS、Yeoman。]]></content>
      <categories>
        <category>Web应用开发工具</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>Nodejs</tag>
        <tag>Web前端依赖包管理工具</tag>
        <tag>Bower</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs数据压缩和解压缩]]></title>
    <url>%2F2017%2F07%2F19%2FNodejs%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[数据压缩数据压缩是指在不丢失信息的前提下，所见数据量以减少存储空间，提高其传输、存储和处理效率，或按照一定的算法对数量进行重新组织，减少数据的冗余和存储空间的一种技术方法。 (在Web应用开发中浏览器会自动的解压所支持格式的压缩文件,解压完成后会将解压后的资源渲染到浏览器,这样资源在传输过程中变得非常小) 常见的压缩技术有： gzip：有GUN软件基金会在1992年发布的开源的数据压缩格式； deflate：由Phil Katz在1993年发布的非专利型无损压缩算法； rar：是由Eugene Roshal在1993年发布的一种压缩格式，是专利文件格式(收费)。 Zlib模块Node.js中的zlib模块提供了基于gzip和deflate技术的压缩工具： 方法 说明 zlib.createGzip[options] 创建一个Gzip对象，用于压缩数据 zlib.createGunzip([options]) 创建一个Gzip对象，用于解压缩gzip格式数据 zlib.createDeflate([options]) 创建一个Deflate对象，用于压缩数据 zlib.createInflate([options]) 创建一个Inflate对象，用于解压缩deflate格式的数据 上述方法返回的对象都是既可写入数据又可读出数据的流对象，可直接使用管道方法语气流对象进行数据传输 gzip压缩可以使用zlib.createGzip( )方法创建的Gzip对象进行文件的压缩：1234567const zlib=require('zlib');const fs=require('fs');var input=fs.createReadStream('8.html');var output=fs.createWriteStream('8.html.gzip');var gzip=zlib.createGzip();input.pipe(gzip).pipe(output); gzip解压缩可以使用zlib.createGunzip( )方法创建Gunzip对象进行gzip格式文件的解压缩：1234567const zlib=require('zlib');const fs=require('fs');var input=fs.createReadStream('8.html.gz');var output=fs.createWriteStream('8_backup.html');var gzip=zlib.createGunzip();input.pipe(gzip).pipe(output); deflate压缩1234567const zlib=require('zlib');const fs=require('fs');var input=fs.createReadStream('10.html');var output=fs.createWriteStream('10.html.deflate');var deflate=zlib.createDeflate();input.pipe(deflate).pipe(output); deflate解压缩可以使用zlib.createInflate( )方法创建的Inflate对象进行deflate格式文件的解压缩：1234567const zlib=require('zlib');const fs=require('fs');var input=fs.createReadStream('10.html.deflate');var output=fs.createWriteStream('11_backup.html');var inflate=zlib.createInflate();input.pipe(inflate).pipe(output);]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>Nodejs</tag>
        <tag>ES6</tag>
        <tag>数据加密</tag>
        <tag>数据解密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js常用原生模块+包和NPM]]></title>
    <url>%2F2017%2F07%2F19%2F%E5%8E%9F%E7%94%9F%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Node.js常用原生模块Console模块Node.js中的console模块提供了一种控制台调试输出机制，类似于Chrome浏览器中的console对象的功能。该模块向外界输出两个成员：console class:可用于向任意Node.js输出流对象中执行输出;Global.console 实例：可用于向stdout和stderr中执行输出。 Global.console对象 1.Global.console底层实现方式： 12//global.console 对象的创建过程：global.console=new Console(process.stdout,process.stderr); 2.Global.console底层实现方式： 123456const out=fs.creactWriteStream(‘./appout.log’);const err=fs.creactWriteStream(‘./apperr.log’);const logger=new Console(out,err);var count=5;logger.log(‘count:%d’,count);logger.error(‘count:%d’,count); OS模块OS模块提供了很多用于获得当前操作系统信息的方法。 1234567891011const os=require('os');os.EOL //代表OS End-Of-Line的常量os.tmpdir( ) //返回OS的临时目录os.hostname( ) //返回当前主机名称os.platform( ) //返回当前OS平台类型os.uptime( ) //返回当前已经运行的时间，单位秒os.loadavg( ) //返回1分钟、5分钟、15分钟的系统平均负载os.totalmem( ) //返回OS总内存大小，单位字节os.freemem() //返回OS当前闲置内存大小，单位字节os.cpus( ) //返回CPU内核信息os.networkInterfaces( ) //返回多有的网络接口信息 Readline模块Readline模块提供的Interface对象，可用于从标准输入对象或者其他输入流对象中一行一行的读取数据。 12345678910const readline=require(‘readline’);var reader=readline.createInterface(&#123; input:process.stdin, output:process.stdout&#125;);reader.question(‘Input User Name:’,(line)=&gt;&#123; console.log(‘Logging In as User %s ..’,line); //使用完毕必须关闭，否则解释器不会退出 reader.close();&#125;) Interface对象Interface对象提供了下述成员可供使用：属性成员： input：指定用于读取数据的来源 output：指定写出数据的目标 方法成员： write():向指定的output对象中写出数据 close():关闭输入流 setPrompt()：设置输入提示符 prompt()：输出提示符信息 事件成员： line:读取到一行数据 end:输入流对象读取到末尾 close:输入流被关闭 Readilne模块示例 12345678910111213141516const rl=require('readline');const fs=require('fs');var file=fs.createReadStream('out.log');var reader=rl.createInterface(file,process.stdout);var num=0;reader.on('line',(data)=&gt;&#123; num++; console.log(num+':'+data);&#125;);reader.on('end',()=&gt;&#123; console.log('readering end')&#125;);reader.on('close',()=&gt;&#123; console.log('closeing...'); process.exit(0);&#125;) Query String模块Query String模块提供了处理URL中的查询字符串部分的相关操作。 123456789101112const querystring=require(‘querystring’);var qs=’cid=%E4BD%93%E8%82%B2&amp;siz=10&amp;pno=2’;//从查询字符串中机械出来的数据对象console.log(querystring.parse(qs));var data=&#123;cid:’体育’,size:’10’,pon:’2’&#125;;//将数据对象转换为查询字符串console.log(querystring.stringify(date));//可以知道键值对分隔符，和键值的关联符//第二个参数是键值对的分隔符，第三个参数是键值得分隔符。console.log(qs.stringify(data,';',':')); URL模块URL模块提供了处理URL中不同部分的相关操作。包含以下三个方法: 123456789101112131415161718192021const url=require(‘url’);var requestUrl = ’http://tom:123@tedu.cn:8080/news/n1?pno=2#section3’;//解析出URL中的各组成部分console.log(url.parse(requestUrl));//将查询字符串解析为对象console.log(url.parse(requestUrl,true));var urlObj =&#123;protocol:’http:’,slashes:true,auth:’tom:123’,port:’8080’,hostname:’tedu.cn’,hash:’#section3’,query:&#123;pon:’2’&#125;,pathname:’/news/n1’&#125;;console.log(url.format(urlObj));var baseUrl=’/project/static/base.html’;//根据地址解析出相对URLconsole.log(url.resolve(baseUrl,’../img/1.jpg’)); Path模块Path模块提供了对文件路径进行操作的方法；这些方法只是进行了字符串的相关转换，与文件系统本身没有任何关联。 1234567891011const path=require(‘path’);//解析路径字符串console.log(path.parse(‘C:/user/local/img/1.jpg’));//将路径对象格式化为字符串var obj=&#123;dir:’C:/user/local/img’,base:’1.jpg’&#125;;console.log(path.format(obj));//根据基础路由解析出一个目标路径的绝对路径console.log(path.resolve(‘htdocs/css’,’../img/news’));//根据基础路径，获取目标路径与其相对关系console.log(path.relative(‘htdocs/css’,’htdocs/img.news’)); DNS模块DNS模块提供了域名到IP地址的双向解析功能;包含如下三个方法： 12345678910111213const dns=require(‘dns’);dns.lookup(‘tmooc.cn’,(err,address,family)=&gt;&#123; //把一个域名解析为一个IP地址 console.log(address);&#125;)dns.resolve(‘tmooc.cn’,(err,addresses)=&gt;&#123; //把一个域名解析为一个DNS记录解析数组 console.log(addresses);&#125;)dns.reverse(‘60.221.254.230’,(err,hostname)=&gt;&#123; //把一个IP地址反向解析为一组域名 console.log(hostnames);&#125;) Util模块Util模块提供了若干工具方法，供Node.js其他模块和应用开发者使用。 123456789101112131415const util=require(‘util’);//使用带占位符的格式化字符串var data=&#123; name:’Cola’, proce:2.5, isOnsale:false&#125;;console.log( util.format( ‘NAME:%s,PRICE:%d,ISONSALE:%s,JSON:%j’, data.name,data.price.data.isOnsale.data ));//返回一个对象的字符串形式表示console.log(util.inspect(data)); 使用Util模块还可以实现构造方法间的继承: 1234567891011121314const util=require(‘util’);const EventEmitter=require(‘events’);function DBConnection()&#123; EvenEmitter.call(this);&#125;util.inherits( DBConnection, EvenE, Itter);var conn=new DBConnection();console.log(conn instanceof DBConnection); //trueconsole.log(conn instanceof EventEmitter); //trueconsole.log(DBConnection.super_===EventEmitter); //true Error模块Node.js中”错误对象”分为四种类型： 原生JS提供的错误类型,如 EvalError、SyntaxError、RangeError、ReferenceError、TypeError、URIError。 由操作系统底层限制引起的自动错误，如打开不存在的文件、想关闭的流中写出数据； 断言错误； 应用程序抛出的用户自定义错误。Node.js中所有的错误对象都是Error类型的实例，Error对象可用使用throw关键字进行抛出。 错误处理 同步函数调用抛出的错误都是直接使用throw关键字实现的，可用使用try…catch结构进行捕获以进一步的处理；若不处理，将导致程序崩溃。 12345678const fs=require(‘fs’);//同步函数调用try&#123; var data=fs.readFileSync(‘不存在的文件.txt’);&#125;catch&#123; console.log(err);&#125; 异步函数调用中抛出错误对象不能用try…catch结构进行捕获！错误对象一般作为第一个参数传递给异步回调函数。 123456789const fs=require(‘fs’);//异步函数调用fs.readFile(‘不存在的.txt’,(err,data)=&gt;&#123; if(err)&#123; console.log(‘文件读取失败！’,err); return; &#125; console.log(“文件内容：”+data)&#125;) 如果异步函数调用发生在一个EventEmitter类型的对象上，产生的错误对象可用通过监听器error事件来处理。 123456const net=require(‘net’);var connection=new.connect(‘192.168.0.100’);connection.on(‘error’,(err)=&gt;&#123; console.log(‘无法连接到目标主机’)； return;&#125;) 包和NPMJavaScript的问题JavaScript最初的射击目标是运行于客户端控制页面的交互与行为;随着服务器应用的展开，其在下列方面的问题开始展现： JavaScript没有模块概念。没有原生的密闭作用域支持和依赖管理； JavaScript没有标准库。缺少IO、Socket、加解密等API标准； JavaScript没有标准接口。缺少数据库访问的统一接口； JavaScript没有包管理系统。不能自动加载和安装依赖文件。 由于缺少统一的标准和规范，上述问题限制了服务器端JS更广泛更大规模的应用。 CommonJS规范 CommonJS（http://www.commonjs.org/）不是一门语言,而是为JS在更广范围的应用定义的API标准和规范，最终提供类似于Python、Ruby和Java语言一样丰富的功能。只要遵循了这些规范，JS编写的应用就可以在任何兼容标准的解释器和主机上运行，从而使得JS可以应用于更广泛的领域: 服务器端应用 命令行应用 桌面GUI应用 混合应用CommonJS规范目前已有很多实现，如Node.js、Narwhal、Wakanda等，实现了其定义的常用API，以及模块和包的编写、使用和维护规范。 CommonJS包规范 Package：包,是模块的集合，是在模块基础上更深一步的抽象，类似于C/C++的函数库或者Java/.Net的类库。他将特定功能相关的模块封装起来用于发布、更新、依赖管理和版本控制。根据CommonJS包规范http://wiki.commonjs.org/wiki/Packages/1.1,一个包就是一个目录，内部应该具有如下结构： 一个package.json文件位于顶级目录； 在bin目录先保存二进制文件； 在lib目录选保存JS文件； 在doc目录下保存说明文档； 在test目录下保存单元测试文 require和包 Require方法也是CommonJS规范中的一部分，除了可以引入文件模块之外，还可以引入包，其参数就是包的名称: 1require('my_package'); CommonJS规范要求被引入的包应该位于当前目录或者当前目录的父目录下的node_modules目录下，或者NODE_PATH环境变量指定的目录先,require函数由近及远依次查找。 package.json CommonJS规范规定了用于描述包特征的文件：package.json，内容包括： name:包名。由小写字母、数组和下划线组成; main：主文件名称; description：包说明; version：版本号; authors:作者信息数组。每个元素可包含name、email、web属性; maintainers:包维护者信息数组; bugs：bug提交地址，网站或邮箱; licenses:许可证书数组; repositories：仓库托管地址数组; keywords：关键字数组; dependencies：依赖的包; engines：可以允许的引擎版本; NPM根据CommonJS规范,Node.js已经提供了几十个核心模块，但在更广泛的项目应用中，这些模块显得不足；于是第三方组织和个人开发了更多的扩展包：https://www.npmjs.com/npm:Node package Manager,一个用于下载、安装、查找、更新、删除第三方Node.js包的工具——这些都符合CommonJS包规范；同时，还可以执行打包、发布模块、解决模块间依赖等功能，已经成为Node.js包管理的标准。Node.js的安装文件中，已经集成了NPM包管理工具。 常用的NPM包此外，还有一些日常开发者经常使用到的NPM包： 包名 说明 color 命令行彩色输出 event-stream Stream流操作工具 mocha 单元测试 mysql 连接到MySQL request HTTP客户端 restify RESTfus API搭建 socket.io WebSocket实时通信 xml2js XML转换工具 本地安装和全局安装将下载的NPM包安装在当前项目工作路径： 1$ npm install 包名 安装包将保存在npm root命令所指定的目录下。 可以通过require()来引入本地安装的包。 将下载的NPM包安装在全局: 1$ npm install 包名 -g 安装包将保存在npm root -g命令所指定的目录下。 可以直接在交互模式下使用，不能供脚本文件使用。 NPM包维护 使用npm init命令可以在当前目录下生成一个package.json文件。 使用npm help json命令可以查看package.json文件所有可用的配置选项。 NPM包发布 1 如果希望开源自定义的包，可以将其发布到npmjs.org上：2 在https://www.npmjs.org上注册账号（可以省略）；3 使用npm adduser命令注册新账号或者登陆已有账号；4 进入配置完成的包目录，使用npm publish命令发布包；5 到npmjs.org搜索刚刚发布的包。]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>Nodejs</tag>
        <tag>ES6</tag>
        <tag>Nodejs常用原生模块</tag>
        <tag>包和NPM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs全局对象+定时器+模块系统]]></title>
    <url>%2F2017%2F07%2F18%2FNodejs%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[全局对象Window? 嵌入在浏览器中的V8引擎，支持ES原生对象、BOM和DOM对象，全局对象为BOM中的window； 声明全局作用域的变量和函数默认为window对象的成员—全局对象污染！ Global！ 独立的Node.js环境中，不支持BOM和DOM对象，全局对象称为global/GLOBAL； 声明的全局变量和函数在交互模式下是global对象的成员—全局对象污染；而在脚本模式下不是global对象的成员—避免了全局对象污染。 Global.consoleGlobal.console对象类似于Chrome中的console,用于向stdout和stderr中输出信息。 Global.console向输出流输出： 123456789var data=&#123;id:3,count:36&#125;;console.log(`COUNT IS: %d`,data.count); //想stdout输出日志信息console.info(`COUNT IS:$&#123;data.count&#125;`); //console.log()的别名console.error(`COUNT IS :$&#123;data.count&#125;`); //向stderr输出错误信息console.warn(`COUNT IS :$&#123;data.count&#125;`); //console.error()的别名console.trace('Stack Trace'); //向stderr输出栈轨迹信息 Global.console具有强大的断言功能： 12345678910var data=&#123;id:3,count36,list:[]&#125;;//向stdout输出指定对象的字符串表示console.dir(data);//为真的断言，错误信息不会输出console.assert(data.count&gt;0,'COUNT IS ZERO');//为假的断言，抛出AssertError对象，输出错误信息，且终止脚本执行console.assert(data.list.length&gt;0,'NO DATA AVAILABLE'); Global.console对象测量代码执行耗时： 123456789//使用console对象测量代码的执行耗时：console.time('LONG-LOOP'); //计时开始for(let i;i&lt;1000;i++)&#123; ;&#125;console.timeEnd('LONG-LOOP'); //计时结束//输出结果 ：LONG-LOOP: 523ms Global.process表示执行当前解释器运行所在的进程对象。可以使用该对象获取当前操作系统及运行时信息，并操作脚本所在执行进程。当操作系统启动Node.js解释器执行一个脚本文件时，会将必需的文件从文件系统调入内存，分配必须的内存空间，执行其中的代码—此过程就创建了一个执行进程。全局对象global.process就是这个进程的代码表示。 Peocess对象中与操作系统相关的成员： 123456789101112131415161718192021process.arch //获取CPU架构类型process.platform //获取操作系统类型process.env //获取操作系统环境变量var start =process.hrtime() //获取高精度的计时器（纳秒级）setTimeout(()=&gt;&#123; var diff=process.hrtime(start); //获取两次计时器时间差 console.log("REAL DRUATION: %d",diff[0]*le9+diff[1]);&#125;,1000);process.cwd() //获取当前所在工作目录process.execPath //获取解释器所在目录process.execArgv //获取解释器执行参数process.argv //获取解释器运行时的命令行参数process.versions //获取Node.js版本信息process.uptime() //获取Node.js解释器运行时间（s）process.memoryUsage() //获取内存信息process.pid //获取进程ID号process.kill(pid) //向指定进程ID号发送退出信号 定时器定时器任务：在间隔指定的时间后执行的任务。由于Node.js是单线程处理模型，所有到期要执行的定时器任务统一进入一个事件循环队列，由Node.js解释器依次调用执行。Node.js提供了四种形式的定时器： process.nextTick( )：本次事件循环结束时立即执行的定时器； global.setImmediate( )：下次事件循环立即执行的定时器； global.setTimeout( )：一次性定时器； global.setInterval( )：周期性定时器； setInterval（callaback,delay）:function设置一个按指定周期不断执行的定时器。每隔delay毫秒重复调用回调callback。注意，取决于外部因素，如果操作系统定时器粒度负载，实际间隔可能会改变。间隔值必须在1-2147483647的范围内（包含1和2147483647）。如果该值超出范围，则该值被当做1毫秒处理。一般来说，一个定时器不能超过24.8天。返回一个代表该定时器的引用。clearInterval（timer）:function停止一个之前通过setInterval（）创建的定时器。回调不会再被执行。 12345678var counter=0;var timer=setInterval(()=&gt;&#123; counter++; console.log('%d hello',counter); if(counter&gt;=5)&#123; clearInterval(timer); &#125;&#125;,1000); setTimeout（callaback,delay）:function设置一个一次性定时器。在至少delay毫秒后调用回调callback。实际延迟取决于外部因素，如果操作系统定时器粒度负载，实际间隔可能会改变。间隔值必须在1-2147483647的范围内（包含1和2147483647）。如果该值超出范围，则该值被当做1毫秒处理。一般来说，一个定时器不能超过24.8天。返回一个代表该定时器的引用。clearTimeout（timer）:function停止一个之前通过setTimeout（）创建的定时器。回调不会再被执行。 12345var counter=0;var timer=setTimeout(()=&gt;&#123; counter++; console.log('%d hello',counter);&#125;,1000); setImmediate（callaback,delay）:function设置一个尽可能立即执行的异步任务—下次事件循环开始时。语义上，相当于setTimeout（callback，0）；但最终的执行时机，觉得于系统定时器粒度级系统负载。返回一个代表该定时器的引用。clearImmediate（timer）:function停止一个之前通过setImmediate（）创建的定时器。回调不会再被执行。 1234567891011var counter=0;var time=setImmediate(function ()&#123; counter++; console.log('%d immediate stack...',counter); if(counter&lt;5)&#123; setImmediate(arguments.callee); &#125;else&#123; clearImmediate(time); &#125;&#125;)console.log('end...'); setImmediate（callaback,delay）:functionnextTick定时器不同于setTimeout(fn,0)或者setImmediate（fn）,它指定的定时器任务在本次事件循环结束时立即执行，先于IO事件回调或其他定时器任务。 123456789101112131415161718setImmediate(function () &#123; console.log('immediate 1');&#125;);process.nextTick(function () &#123; console.log('tick1')&#125;);setImmediate(function () &#123; console.log('immediate 2');&#125;);process.nextTick(function () &#123; console.log('tick2')&#125;);console.log('end...')；// end...// tick1// tick2// immediate 1// immediate 2 更多的全局函数 函数名 说明 decodeURI() 解码一个编码的URI decodeURIComponent() 解码一个编码的URI组件 encodeURI() 把字符串编码为URI encodeURIComponent() 把字符串编码为URI组件 escape() 对字符串进行编码 unescape() 对由escape（）编码的字符串进行解码 parseInt() 解析一个字符串并返回一个整数 parseFloat() 解析一个字符串并返回一个浮点数 isNaN() 检测是否为NaN isFinite() 检查是否为有穷大的数字 eval() 计算指定字符串，将其作为语句来执行 模块系统类似于其他语言中的“包（package）”或“名称空间（namespace）”等概念，Node.js使用“模块（Module）”来规划不同的功能对象。 Node.js中每个被加载的文件对应一个模块对象。 一个文件/模块被第一次加载后，会在内存中保存对应的缓存对象；对一个模块多次重复引入，会使用该缓存对象，从而避免了重复加载到账创建出多个完全相同的模块对象。 主模块和子模块与C等其他语言类似，Node.js启动时运行的第一个模块称为“主模块”—main module 123//可以使用下述方法获取主模块对象consoloe.log(process.mainModule);console.log(require.main); 除主模块外的其他模块都成为”子模块”。每个子模块都可以导出（exports）一些数据或方法提供其他模块使用。要使用其他模块的功能，当前模块需要引入（require）指定的模块。 12//判断当前模块是否是“主模块”console.log(module===process.mainModule); 模块的封装Node.js中的每个.js文件都自成一个模块，有自己专属成员属性和方法—”模块作用域”变量。模块文件中声明的变量和函数也都属于”模块作用域”。根本原因在于，Node.js在编译模块文件时会对其首位进行如下的包装： 12345678(function(exprots,require,module,__filename,__dirname)&#123; module.exports=&#123;&#125;; exports=module.exports; //模块文件中原有的全部内容 return module.exports;&#125;) 模块作用域变量注意：声明在模块文件中的”全局变量” 不再是真正的全局变量，既不是global对象的成员；而是当前模块内部的局部变量。 成员名 说明 __dirname:String 当前模块文件所在的目录名 __filename:String 当前模块文件的文件名 module:Object 指向当前模块的应用 module.exports:Object 当前模块待导出的供其他模块使用的对象 exports:Object 指向module.exports对象的引用 require:Function 引入其他模块，使用其他模块的module.exports对象 Module.exports和exports一个模块可以导出一个供其他模块使用的对象，这个对象就是module.exports对象。起始时，他是一个{ }对象。Exports对象作为module.exports对象的引用，可以作为module.expots的简写形式。注意:其他模块可以引入的是module.exports对象，而不是exports对象！所以下面两张情形的结果是不同的： 1234567891011exports.add=function()&#123;&#125;等同于module.exports.add=function()&#123;&#125;exports=function()&#123;//无效&#125;不同于module.exports=function()&#123;&#125; 模块的分类1 核心模块 被编译进二进制执行文件，可以被解析器直接使用，加载速度最快； 模块名 说明 global 全局对象模块 console 控制台模块 util 提供常用函数的集合，用于弥补核心JS的功能过于精简的不足 event 实现了Node.js的是钱驱动型的异步调用 fs 文件系统IO/操作模块 http 提供基于HTTP协议的请求和响应 net 提供基于Socket的网络连接 dns DNS解析服务模块 crypto 加密和解密功能模块 2 文件模块 没有后缀的文件模块，被作为JavaScript文本加载； .js后缀的文件模块，被作为JavaScript文本加载； .json后缀的文件模块，被作为json字符串加载； .node后缀的文件模块，被作为C/C++二进制插件加载； 3 目录模块 包含package.json文件的目录； 包含index.js文件的目录； 包含index.json文件的目录； 包含index.node文件的目录； Require()模块Require()函数用于引入另一个模块，其可用的参数有如下形式： 12345678910/*核心模块*/const http=require('http');/**相对或绝对路径开头的模块名**/const c1=require('./calc'); //可能是文件模块或目录模块const c2=require('../calc'); //可能是文件模块或目录模块const c3=require('/calc'); //可能是文件模块或目录模块/**不以路径名开头的非核心模块名**/const mysql=require('mysql'); //可能是文件模块或目录模块 非核心模块的查找路径对于每个加载的文件模块，创建这个模块对象的时候，module对象便有一个paths属性，用于指定查找不以“./”或“../”或“/”开头的模块名时所用的路径。其值例如： 1234['c:\\mynode\\project1\\lib\\node_modules', 'c:\\mynode\\project1\\node_modules', 'c:\\mynode\\node_modules', 'c:\\node_modules'] 模块查找的顺序 文件/目录模块的缓存 原生模块的缓存 原生模块 文件/目录模块]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>Nodejs</tag>
        <tag>ES6</tag>
        <tag>Nodejs全局对象</tag>
        <tag>Nodejs定时器</tag>
        <tag>Nodejs模块系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs基础]]></title>
    <url>%2F2017%2F07%2F17%2FNodejs%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1.Node概述JavaScript是一门运行在浏览器（客户端）中的语言，主要对象包括：ES原生对象（11个）、BOM对象、DOM对象。 Node.js是运行于服务器的语言，类似于PHP、JSP、ASP.NET，主要对象包括：ES原生对象、1000+多个扩展对象。 一种语言通吃前后端！走在最前端 Node体系结构 Node能做什么 Node不适合做什么 Node特点 简单，避免过度设计； 单线程逻辑处理； 非阻塞I/O处理； 事件驱动编程； 无锁机制，不会产生死锁； 支持上万个并发链接； Node性能Node.js与PHP+Nginx（比Apache性能更高的服务器）组合性能测试对比：（3000并发连接、持续30秒的压力测试下） 输出“Hello World”响应: PHP每秒响应请求次数3624，平均每个请求响应为0.39秒； Node.js每秒响应请求次数为7677，平均每个请求响应时间为0.13秒； 执行对MySQL的查询操作: PHP每秒响应请求数为1293，平均每个请求响应时间为0.82秒； Node.js每秒响应请求数为2999,平均每个请求响应时间为0.33秒； Node解释器下载与安装下载地址：https://nodejs.org版本：LTS：Long Term Support（稳定版） Node.js有两种运行模式交互模式：REPL模式，Read Evaluate Print Loop 1$ e:/mynode&gt;node 一般用于测试，需要输入一行执行一行。 执行运算，输出执行结果，继续下一次循环… 交互模式下，node.js自带的模块无需使用require（）引入。 脚本模式：把要执行的所有代码置于一个文本文件中，可以.js后缀，也可以没有1$ e:/mynode&gt;node x.js 正常项目应用中都使用脚本模式。 将所有的语句编写在独立的脚本文件中，一次性执行。 脚本模式下，除了全局对象及其相关成员外，所有其他模块中声明的 对象和方法必须使用require（）引入。 2.Node语法数据类型：原型类型（Promitive Type）： String 、number、boolean、null、undefined 原始类型数据直接赋值即可。 引用类型（Reference Type）： 包含ES原生对象、Node.js对象、用户自定义对象三类； 引用类型数据一般需要使用new关键字创建。 Template String模板字符串 - ES6新特性ES6标准中，可以使用“模板”方式定义字符串：12345var user=&#123; ename：'tom', age:20&#125;var str=`我的名字叫$&#123;user.ename&#125;,今年岁$&#123;user.age&#125;！`; 模板字符串中可以使用${ }拼接变量，并执行运算：（可执行js表达式） 变量和常量声明变量 123var empName1=’Tom’; //局部变量empName2=’Mary’; //全局变量//注意：省略var的全局变量在严格模式下是非法的 声明常亮 - ES6新特性 12const fs=require('fs');//注意：严格模式下，修改常量的值是非法的。 变量的作用域（let） - ES6新特性ES6中，变量的作用域分为三种： 1 局部作用域：只能在当前函数内使用2 全局作用域：可以在任意函数内使用—-是全局对象的成员3 块级作用域：只能在当前快内使用—-ES6新特性 12345"use strict"; //快级作用于需要运行在严格模式for(let i=0;i&lt;10;I++)&#123; console.log(i); //执行正常&#125;console.log(i) //执行错误 运算符 1.算数运算符: + - * / % ++ – 2.比较运算: &gt; &lt; &gt;= &lt;= == === != !== 3.逻辑运算符: &amp;&amp; || ！ &amp; | 4.位运算: &amp; | ~ ^ &lt;&lt; &gt;&gt; &gt;&gt;&gt; 5.赋值运算: += -= *= /= %= 6.三目运算: ？： 7.特殊运算符: typeof instanceof void , . [] =&gt; 逻辑结构循环结构 for for…in… for…of… ——ES6新特性 while do…while 选择结构 if…else… switch…case for…in和for…of 1.for…in循环可以遍历数组的下标或对象的成员名 1234var arr=[90,80,70];for(let i in arr)&#123; console.log(i) //将输出0 1 2&#125; 2.ES6新增的for…of循环可以遍历数组的元素值 1234var arr=[90,80,70];for(let v in arr)&#123; console.log(v) //将输出90 80 70&#125; 函数 函数：就是一系列语句的集合，为了实现某种可以重复使用的特定功能。 命名函数：指定了名称的函数对象 1234function add(num1,num2)&#123; return num1+num2;&#125;add(10,20); 匿名函数：未指定名称的函数对象 1234function add(num)&#123; arguments.callee(num-1); //递归调用匿名函数&#125;add(10,20); 自调函数：js中，全局变量会成为全局对象的成员，造成全局对象的污染；很多js工具和框架在设计时，为了避免此问题，常常使用匿名函数 自调： 123(function(g)&#123; var ns='myNamespace';&#125;)(global) 123+(function(g)&#123; var ns='myNamespace';&#125;)(global) 箭头函数：ES6中，为了简化匿名回调函数的编写，引入了箭头函数语法： 123setInterval(()=&gt;&#123; console.log('Hello');&#125;,1000) 1234fs.readFile('index.html',(err,data)=&gt;&#123; if(err)throw err; console.log(data)&#125;) 闭包闭包（Closure），是ECMAScript中所特有的现象。一个闭包，可以看做 一种特殊的对象，包含若干函数对象，以及这些函数对象执行时必须依赖的 执行上下文对象。 123456789function outer()&#123; var num=10; function inner()&#123; console.log(num); &#125; return inner;&#125;var fn=outer();fun(); 闭包引起的错误无论前端JS还是Node.js，闭包使用不当，都可能引起看似奇怪的错误： 12345678//假设前端页面中有三个button元素var list=document.querySelectorAll('button');for(var i=0;i&lt;list.length;i++)&#123; list[i].onclick=function()&#123; console.log(i); &#125;&#125;//点击每个按钮，会分别输出什么？ 对象ECMAScript中提供了多种创建对象的语法： 1.对象直接量方式 1var e1=&#123;ename:'tom',age:20&#125;; 2.构造函数方式 12345function Emp()&#123; this.ename=ename; this.work=function()&#123; &#125;&#125;var e2=new Emp('Mary'); 3.原型继承方式 12var parent=new Object();var child=Object.create(parent); 4.class方式—ES6新特性 class关键字 ES6借鉴了其他语言中声明对象的方式，正式启用了class关键字，有了“类”的概念。 Class：类,是一组相似对象的属性和行为的抽象集合。 Instance：实例，是从属于某个类的一个具体对象。 class对象的继承 继承，是面向对象编程的一个重要概念，使子对象可以继承父对象中声明的成员，从而极大的提高代码的复用性。 ES6之前的继承都是通过对象的原型（prototype）来实现的： 12345678var graphic=&#123;bgColor:'red',borderColor:'black'&#125;var rect=&#123;width:500,height:300&#125;;Object.setPrototypeOf(rect,graphic); //原型继承console.log(rect.width);console.log(rect.height);console.log(rect.bgColor); //继承来的成员console.log(rect.borderColor); //继承来的成员 ES6中的继承通过使用class配合extends关键字来实现。 12345678910111213141516171819202122//声明父类class Emp&#123; constructor(ename)&#123; this.ename=ename; &#125; work()&#123; return `ENAME:$&#123;this.ename&#125;`; &#125;&#125;//声明子类class Programmer extend Emp&#123; construcor(ename,skills)&#123; super(ename); this.skills=skills; &#125; work()&#123; return super.work()+`SKILLS:$&#123;this.skills&#125;`; &#125;&#125;var p1=new Programmer('Tom','javascript');console.log(p1.work()); class对象的分类 ECMAScript预定义对象:String、Boolean、Number、Date、Array、Math、RegExp、 Function、 Object、Error、EvalError、RangeError、 ReferenceError、SyntaxError、TypeError、URIError等 16个； Node.js核心模块定义的对象:Buffer、WriteStream、Socket、ChildProcess等数百个； 第三方模块定义的对象 用户自定义的对象]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>Nodejs</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo基础使用]]></title>
    <url>%2F2017%2F03%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[欢迎来到 Hexo! 这是你的第一篇文章。 检查 文档 以获取更多信息。如果在使用Hexo时遇到任何问题, 您可以在故障排除中 找到答案，或者您可以在 GitHub 询问我。 快速开始创建一个新的帖子1$ hexo new "我的新文章" 更多信息: 写作 运行服务器1$ hexo server 更多信息: 服务器 生成静态文件1$ hexo generate 更多信息: 生成 部署到远程站点1$ hexo deploy 更多信息: 部署]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>Hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
